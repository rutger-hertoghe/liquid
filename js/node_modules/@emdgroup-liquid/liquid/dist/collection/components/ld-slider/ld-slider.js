import { Component, Element, Event, Fragment, Host, h, Prop, State, Watch, Method, } from '@stencil/core';
import { getClassNames } from 'src/liquid/utils/getClassNames';
const findClosest = (items, currValue) => items.length
  ? items.reduce((prevItem, item) => Math.abs(item - currValue) < Math.abs(prevItem - currValue)
    ? item
    : prevItem)
  : currValue;
const findNext = (items, currValue) => findClosest(items.filter((item) => item > currValue), currValue);
const findPrev = (items, currValue) => findClosest(items.filter((item) => item < currValue), currValue);
let sliderCount = 0;
/**
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 * @part indicator - Stop/step indicator div elements
 * @part input - `input` elements
 * @part label - `ld-sr-only` elements labelling an input
 * @part output - `output` elements
 * @part value-label - `div` element containing the max/min/stops values + unit
 */
export class LdSlider {
  constructor() {
    this.idPrefix = `ld-slider-${++sliderCount}`;
    /** Disabled state of the slider */
    this.disabled = false;
    /** Prevents rendering of the stop labels below the slider */
    this.hideStopLabels = false;
    /** Prevents rendering of the value labels below the slider */
    this.hideValueLabels = false;
    /** Makes the current values only visible on interaction */
    this.hideValues = false;
    /** Specifies the legal number intervals */
    this.indicators = false;
    /** "From" value label (when exactly 2 values are given) */
    this.labelFrom = 'From';
    /** "To" value label (when exactly 2 values are given) */
    this.labelTo = 'To';
    /** "Value" label (when exactly 2 values are given) */
    this.labelValue = 'Value';
    /** Specifies the maximum value allowed */
    this.max = 100;
    /** Specifies the minimum value allowed */
    this.min = 0;
    /** Swap which areas are being marked as selected and deselected */
    this.negative = false;
    /** Allows swapping of thumbs */
    this.swappable = false;
    /** Specifies the default value */
    this.value = String(this.min);
    /** Width of the slider */
    this.width = '100%';
    this.valueLabels = [];
    this.steps = [];
    this.values = [];
    this.handleTrackClick = (ev) => {
      if (ev.composedPath()[0] !== this.el) {
        return;
      }
      const afterStyles = getComputedStyle(this.el, 'after');
      const paddingLeft = Number.parseInt(getComputedStyle(this.el).paddingLeft) || 0;
      const marginLeft = Number.parseInt(afterStyles.marginLeft) || 0;
      const trackWidth = Number.parseInt(afterStyles.width);
      const clickPosition = ev.offsetX - paddingLeft - marginLeft;
      const newValue = Math.round((clickPosition / trackWidth) * (this.max - this.min)) +
        this.min;
      const values = [...this.values];
      const index = values.indexOf(findClosest(values, newValue));
      const correctedValue = this.getCorrectedValue(newValue, index, values);
      values.splice(index, 1, correctedValue);
      this.value = values.join(',');
    };
    this.handleInput = (ev, index) => {
      const target = ev.target;
      if (this.ariaDisabled === 'true') {
        target.value = String(this.values[index]);
        return;
      }
      const currValue = Number.parseInt(target.value, 10);
      const values = [...this.values];
      const correctedValue = this.getCorrectedValue(currValue, index, values, true);
      values[index] = correctedValue;
      if (correctedValue !== currValue) {
        target.value = String(correctedValue);
      }
      const newValue = values.join(',');
      if (this.value !== newValue) {
        this.value = values.join(',');
      }
    };
    this.handleKeyDown = (ev, index) => {
      const target = ev.target;
      if (this.ariaDisabled === 'true') {
        target.value = String(this.values[index]);
        return;
      }
      const prevValue = Number.parseInt(target.value, 10);
      const values = [...this.values];
      let currValue;
      if (this.stops && !this.snapOffset) {
        switch (ev.key) {
          case 'ArrowDown':
          case 'ArrowLeft':
            currValue = findPrev(this.steps, prevValue);
            break;
          case 'ArrowRight':
          case 'ArrowUp':
            currValue = findNext(this.steps, prevValue);
        }
      }
      else if (this.snapOffset) {
        switch (ev.key) {
          case 'ArrowDown':
          case 'ArrowLeft':
            currValue = prevValue - 1;
            break;
          case 'ArrowRight':
          case 'ArrowUp':
            currValue = prevValue + 1;
        }
      }
      if (currValue === undefined) {
        return;
      }
      ev.preventDefault();
      const correctedValue = this.getCorrectedValue(currValue, index, values);
      if (correctedValue === prevValue) {
        return;
      }
      values[index] = correctedValue;
      target.value = String(correctedValue);
      const newValue = values.join(',');
      if (this.value !== newValue) {
        this.value = values.join(',');
      }
    };
    this.getCorrectedValue = (currValue, index, values, snap = false) => {
      const prevValue = values[index - 1];
      const nextValue = values[index + 1];
      if (currValue < this.min) {
        return this.min;
      }
      if (currValue > this.max) {
        return this.max;
      }
      if (!this.swappable && prevValue > currValue) {
        return prevValue;
      }
      if (!this.swappable && nextValue < currValue) {
        return nextValue;
      }
      if (snap && this.snapOffset !== undefined) {
        const stepToSnapTo = this.steps.find((step) => currValue <= step + this.snapOffset &&
          currValue >= step - this.snapOffset);
        return stepToSnapTo !== null && stepToSnapTo !== void 0 ? stepToSnapTo : currValue;
      }
      if (this.steps.length && this.snapOffset === undefined) {
        return findClosest(this.steps, currValue);
      }
      return currValue;
    };
    this.validateValue = (currValue, index, values) => currValue === this.getCorrectedValue(currValue, index, values);
    this.correctValues = (values) => {
      const correctedValues = values.map(this.getCorrectedValue);
      if (!correctedValues.every(this.validateValue)) {
        return this.correctValues(correctedValues);
      }
      return correctedValues;
    };
    this.updateValues = (autoCorrectValues = false) => {
      const values = this.value
        .split(',')
        .map((value) => Number.parseInt(value, 10));
      if (!values.every(this.validateValue)) {
        if (autoCorrectValues) {
          this.value = this.correctValues(values).join(',');
        }
        return false;
      }
      this.values = values;
      return true;
    };
  }
  /** Focuses the toggle */
  async focusInner() {
    var _a;
    (_a = this.firstSliderRef) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
  }
  updateState() {
    this.steps = this.stops
      ? [
        this.min,
        ...this.stops
          .split(',')
          .map((valueLabel) => Number.parseInt(valueLabel, 10)),
        this.max,
      ]
      : this.step
        ? Array(Math.floor((this.max - this.min) / this.step) + 1)
          .fill(this.min)
          .map((min, index) => min + index * this.step)
        : [];
    this.valueLabels = this.stops ? [...this.steps] : [this.min, this.max];
  }
  handleValueChange() {
    const success = this.updateValues();
    if (success) {
      this.ldchange.emit(this.values);
    }
  }
  componentWillLoad() {
    this.updateState();
    this.updateValues(true);
  }
  render() {
    const cssValues = this.values.reduce((prev, curr, index) => {
      prev[`--value${index}`] = curr;
      return prev;
    }, {});
    return (h(Host, { class: getClassNames([
        'ld-slider',
        this.hideValueLabels && 'ld-slider--padded',
        this.size && `ld-slider--${this.size}`,
      ]), onClick: this.handleTrackClick, role: "group", style: Object.assign(Object.assign({}, cssValues), { '--ld-slider-width': this.width, '--min': String(this.min), '--max': String(this.max), '--fill': (this.negative
          ? `
linear-gradient(
  90deg,
  red 100%,
  transparent 0
),`
          : '') +
          this.values
            .map((_, index) => `
linear-gradient(
  90deg,
  red
    calc(
      var(--ld-slider-radius) - var(--ld-slider-track-margin) +
        (var(--value${index}) - var(--min)) / var(--ld-slider-diff) *
        (var(--ld-slider-useful-width)${this.width === '100%' ? ' + 2 * var(--ld-slider-track-margin)' : ''})
    ),
  transparent 0
)`)
            .join(',') }) },
      this.values.map((value, index) => {
        var _a;
        return (h(Fragment, null,
          h("ld-sr-only", { id: `${this.idPrefix}-label-${index}`, key: `label-${index}`, part: "label" }, this.values.length === 2
            ? index === 0
              ? this.labelFrom
              : this.labelTo
            : `${this.labelValue} ${index + 1}`),
          h("input", { "aria-disabled": this.disabled || this.ariaDisabled === 'true'
              ? 'true'
              : undefined, "aria-labelledby": `${this.idPrefix}-label-${index}`, "aria-valuetext": this.unit ? value + this.unit : undefined, class: "ld-slider__input", disabled: this.disabled, id: `${this.idPrefix}-value-${index}`, key: `input-${index}`, max: this.max, min: this.min, onInput: (ev) => this.handleInput(ev, index), onKeyDown: (ev) => this.handleKeyDown(ev, index), part: "input focusable", ref: index === 0
              ? (ref) => {
                this.firstSliderRef = ref;
              }
              : undefined, step: this.snapOffset !== undefined ? undefined : this.step, style: 
            // prevents that thumb is not movable, when swappable prop is not set
            value === this.max && this.values[index - 1] === this.max
              ? {
                zIndex: '2',
              }
              : undefined, tabindex: this.ldTabindex, type: "range", value: value }),
          h("output", { class: getClassNames([
              'ld-slider__output',
              !this.hideValues && 'ld-slider__output--permanent',
            ]), htmlFor: `${this.idPrefix}-value-${index}`, key: `output-${index}`, part: "output", style: {
              '--now': `var(--value${index})`,
              '--unit': `"${(_a = this.unit) !== null && _a !== void 0 ? _a : ''}"`,
            } })));
      }),
      this.indicators &&
        this.steps.map((step) => (h("div", { class: "ld-slider__indicator", key: `indicator-${step}`, part: "indicator", style: { '--now': String(step) } }))),
      !this.hideValueLabels &&
        this.valueLabels.map((valueLabel, index) => (index === 0 ||
          index === this.valueLabels.length - 1 ||
          !this.hideStopLabels) && (h("div", { class: getClassNames([
            'ld-slider__value-label',
            index === 0 && 'ld-slider__value-label--first',
            index === this.valueLabels.length - 1 &&
              'ld-slider__value-label--last',
          ]), key: `value-label-${valueLabel}`, part: "value-label", style: { '--now': String(valueLabel) } },
          valueLabel,
          this.unit)))));
  }
  static get is() { return "ld-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-slider.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-slider.shadow.css"]
  }; }
  static get properties() { return {
    "ariaDisabled": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Alternative disabled state that keeps element focusable"
      },
      "attribute": "aria-disabled",
      "reflect": false
    },
    "disabled": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Disabled state of the slider"
      },
      "attribute": "disabled",
      "reflect": false,
      "defaultValue": "false"
    },
    "hideStopLabels": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Prevents rendering of the stop labels below the slider"
      },
      "attribute": "hide-stop-labels",
      "reflect": false,
      "defaultValue": "false"
    },
    "hideValueLabels": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Prevents rendering of the value labels below the slider"
      },
      "attribute": "hide-value-labels",
      "reflect": false,
      "defaultValue": "false"
    },
    "hideValues": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Makes the current values only visible on interaction"
      },
      "attribute": "hide-values",
      "reflect": false,
      "defaultValue": "false"
    },
    "indicators": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Specifies the legal number intervals"
      },
      "attribute": "indicators",
      "reflect": false,
      "defaultValue": "false"
    },
    "labelFrom": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "\"From\" value label (when exactly 2 values are given)"
      },
      "attribute": "label-from",
      "reflect": false,
      "defaultValue": "'From'"
    },
    "labelTo": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "\"To\" value label (when exactly 2 values are given)"
      },
      "attribute": "label-to",
      "reflect": false,
      "defaultValue": "'To'"
    },
    "labelValue": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "\"Value\" label (when exactly 2 values are given)"
      },
      "attribute": "label-value",
      "reflect": false,
      "defaultValue": "'Value'"
    },
    "max": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Specifies the maximum value allowed"
      },
      "attribute": "max",
      "reflect": false,
      "defaultValue": "100"
    },
    "min": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Specifies the minimum value allowed"
      },
      "attribute": "min",
      "reflect": false,
      "defaultValue": "0"
    },
    "negative": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Swap which areas are being marked as selected and deselected"
      },
      "attribute": "negative",
      "reflect": false,
      "defaultValue": "false"
    },
    "size": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'sm' | 'lg'",
        "resolved": "\"lg\" | \"sm\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Size of the thumb(s)."
      },
      "attribute": "size",
      "reflect": false
    },
    "snapOffset": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Offset inside which a thumb snaps to a stop point"
      },
      "attribute": "snap-offset",
      "reflect": false
    },
    "step": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Specifies the legal number intervals"
      },
      "attribute": "step",
      "reflect": false
    },
    "stops": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Adds custom stop points to the slider (instead of steps)"
      },
      "attribute": "stops",
      "reflect": false
    },
    "swappable": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Allows swapping of thumbs"
      },
      "attribute": "swappable",
      "reflect": false,
      "defaultValue": "false"
    },
    "ldTabindex": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number | undefined",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Tab index of the input(s)."
      },
      "attribute": "ld-tabindex",
      "reflect": false
    },
    "unit": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Adds custom stop points to the slider (instead of steps)"
      },
      "attribute": "unit",
      "reflect": false
    },
    "value": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Specifies the default value"
      },
      "attribute": "value",
      "reflect": true,
      "defaultValue": "String(this.min)"
    },
    "width": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Width of the slider"
      },
      "attribute": "width",
      "reflect": false,
      "defaultValue": "'100%'"
    }
  }; }
  static get states() { return {
    "valueLabels": {},
    "steps": {},
    "values": {}
  }; }
  static get events() { return [{
      "method": "ldchange",
      "name": "ldchange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "typeof this.values",
        "resolved": "number[]",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "focusInner": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "Focuses the toggle",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "max",
      "methodName": "updateState"
    }, {
      "propName": "min",
      "methodName": "updateState"
    }, {
      "propName": "step",
      "methodName": "updateState"
    }, {
      "propName": "stops",
      "methodName": "updateState"
    }, {
      "propName": "value",
      "methodName": "handleValueChange"
    }]; }
}
