import { Component, Element, Event, h, Host, Method, State, } from '@stencil/core';
import { getClassNames } from '../../../utils/getClassNames';
/**
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdAccordionPanel {
  constructor() {
    this.initialized = false;
    this.transitionEnabled = false;
    this.innerPanelExpanding = false;
    this.applyMaxHeight = (additionalHeightFromInnerPanel = 0) => {
      if (additionalHeightFromInnerPanel) {
        this.innerPanelExpanding = true;
      }
      // Apply max-height on outer panel inside nested accordion.
      if (this.expanded) {
        this.ldaccordionmaxheightchange.emit(this.el.scrollHeight);
      }
      this.maxHeight = this.expanded
        ? this.el.scrollHeight + additionalHeightFromInnerPanel
        : 0;
    };
    this.handleInnerMaxHeightChange = (ev) => {
      if (ev.target === this.el)
        return;
      ev.stopImmediatePropagation();
      this.applyMaxHeight(ev.detail);
    };
    this.onTransitionEnd = (ev) => {
      if (ev.target === this.el) {
        this.innerPanelExpanding = false;
      }
    };
  }
  /**
   * @internal
   * Updates expanded state.
   */
  async setExpanded(expanded) {
    this.expanded = expanded;
    this.applyMaxHeight();
  }
  componentDidLoad() {
    setTimeout(() => {
      this.resizeObserver = new ResizeObserver(() => {
        // When a panel is expanding inside a nested accordion, the nested panel
        // takes over the responsibility for updating the max-height on the outer
        // panel. In other words: We disable the observer callback function in
        // order to instantly update the max-height for a better performance.
        if (!this.innerPanelExpanding) {
          this.applyMaxHeight();
        }
      });
      this.resizeObserver.observe(this.contentRef);
      this.initialized = true;
    });
  }
  disconnectedCallback() {
    this.resizeObserver.unobserve(this.contentRef);
  }
  render() {
    const cl = getClassNames([
      'ld-accordion-panel',
      this.expanded && 'ld-accordion-panel--expanded',
      this.initialized && 'ld-accordion-panel--initialized',
    ]);
    return (h(Host, { style: { '--ld-accordion-panel-max-height': this.maxHeight + 'px' }, class: cl, onTransitionEnd: this.onTransitionEnd, onLdaccordionmaxheightchange: this.handleInnerMaxHeightChange },
      h("div", { part: "content", ref: (ref) => (this.contentRef = ref), class: "ld-accordion-panel__content" },
        h("slot", null))));
  }
  static get is() { return "ld-accordion-panel"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-accordion-panel.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-accordion-panel.shadow.css"]
  }; }
  static get states() { return {
    "expanded": {},
    "initialized": {},
    "transitionEnabled": {},
    "maxHeight": {},
    "resizeObserver": {},
    "innerPanelExpanding": {}
  }; }
  static get events() { return [{
      "method": "ldaccordionmaxheightchange",
      "name": "ldaccordionmaxheightchange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted on accordion panel max-height change."
      },
      "complexType": {
        "original": "number",
        "resolved": "number",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "setExpanded": {
      "complexType": {
        "signature": "(expanded: boolean) => Promise<void>",
        "parameters": [{
            "tags": [],
            "text": ""
          }],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "",
        "tags": [{
            "name": "internal",
            "text": "Updates expanded state."
          }]
      }
    }
  }; }
  static get elementRef() { return "el"; }
}
