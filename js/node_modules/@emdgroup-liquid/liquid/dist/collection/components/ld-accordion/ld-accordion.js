import { Component, Element, h, Host, Listen, Prop } from '@stencil/core';
import { getClassNames } from '../../utils/getClassNames';
import { getScrollParent } from '../../utils/scroll';
/**
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdAccordion {
  constructor() {
    this.scrollIntoViewOnTransitionEnd = false;
    /** Sets a small gap between each accordion section. */
    this.detached = false;
    /** Applies rounded corners. */
    this.rounded = false;
    /** When set to true, an open accordion element closes, if anthorer one opens. */
    this.single = false;
    this.scrollIntoView = (section) => {
      var _a;
      const scrollParent = getScrollParent(section);
      const toggle = section.querySelector('ld-accordion-toggle');
      const panel = section.querySelector('ld-accordion-panel');
      // singleModeDelta is the height of the currently open panel, that needs
      // to be subtracted from the scroll amount in single mode.
      const allSections = Array.from(section.parentElement.children);
      const singleModeDelta = this.single && !this.scrollIntoViewOnTransitionEnd
        ? ((_a = allSections
          .slice(0, allSections.findIndex((sec) => sec === section))
          .find((sec) => sec.classList.contains('ld-accordion-section--expanded'))) === null || _a === void 0 ? void 0 : _a.children[1].scrollHeight) || 0
        : 0;
      const panelOffsetToScrollParent = scrollParent.scrollTop +
        panel.getBoundingClientRect().top -
        Math.max(0, scrollParent.getBoundingClientRect().top);
      const scrollPaddingTop = parseFloat(window.getComputedStyle(scrollParent)['scrollPaddingTop']) || 0;
      // targetOffsetBottom is the distance from the scrollParent top to the
      // bottom of the section that is being expanded in its expanded state.
      const targetOffsetBottom = panelOffsetToScrollParent +
        Math.min(panel.scrollHeight, scrollParent.clientHeight - toggle.clientHeight - scrollPaddingTop) -
        singleModeDelta;
      // If an accordion section expands at the bottom end of the accordion
      // The scroll container may not have a sufficient height at that time
      // in order to be scrollable to the target offset. In this case we
      // postpone the scrolling to the transition end event.
      if (!this.scrollIntoViewOnTransitionEnd &&
        scrollParent.scrollHeight < targetOffsetBottom) {
        this.scrollIntoViewOnTransitionEnd = true;
        return;
      }
      if (!this.el.closest('ld-accordion-panel') &&
        scrollParent.clientHeight + scrollParent.scrollTop < targetOffsetBottom) {
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        scrollParent.scrollTo({
          top: targetOffsetBottom - scrollParent.clientHeight,
          behavior: prefersReducedMotion ? 'auto' : 'smooth',
        });
      }
    };
    this.focusToggle = (currentToggle, dir) => {
      var _a;
      const toggleToFocus = (_a = (dir === 'prev'
        ? currentToggle.parentElement.previousElementSibling
        : currentToggle.parentElement.nextElementSibling)) === null || _a === void 0 ? void 0 : _a.querySelector('ld-accordion-toggle');
      if (toggleToFocus) {
        toggleToFocus.focusInner();
      }
    };
    this.onKeydown = (ev) => {
      if (ev.target.tagName !== 'LD-ACCORDION-TOGGLE') {
        return;
      }
      switch (ev.key) {
        case 'ArrowUp': {
          ev.preventDefault();
          this.focusToggle(ev.target, 'prev');
          return;
        }
        case 'ArrowDown': {
          ev.preventDefault();
          this.focusToggle(ev.target, 'next');
          return;
        }
      }
    };
    this.onTransitionEnd = (ev) => {
      const target = ev.target;
      if (!this.scrollIntoViewOnTransitionEnd ||
        target.tagName !== 'LD-ACCORDION-PANEL' ||
        target.closest('ld-accordion') !== this.el ||
        !target.closest('ld-accordion-section').expanded) {
        return;
      }
      this.scrollIntoView(target.closest('ld-accordion-section'));
      this.scrollIntoViewOnTransitionEnd = false;
    };
  }
  handleAccordionExpandChange(ev) {
    if (ev.target.tagName !== 'LD-ACCORDION-SECTION')
      return;
    // In single mode, close sibling sections of open section.
    if (this.single && ev.target.expanded) {
      const siblings = [...ev.target.parentElement.children].filter((section) => section !== ev.target);
      siblings.forEach((section) => {
        section.expanded = false;
      });
    }
    if (ev.detail /* expanded */) {
      this.scrollIntoView(ev.target);
    }
  }
  render() {
    const cl = getClassNames([
      'ld-accordion',
      this.detached && 'ld-accordion--detached',
      this.brandColor && 'ld-accordion--brand-color',
      !this.brandColor && this.tone && `ld-accordion--${this.tone}`,
      this.rounded && 'ld-accordion--rounded',
    ]);
    return (h(Host, { class: cl, onKeydown: this.onKeydown, onTransitionEnd: this.onTransitionEnd },
      h("slot", null)));
  }
  static get is() { return "ld-accordion"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-accordion.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-accordion.shadow.css"]
  }; }
  static get properties() { return {
    "brandColor": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Style the accordion so that it looks good on the primary color of the current theme."
      },
      "attribute": "brand-color",
      "reflect": false
    },
    "detached": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Sets a small gap between each accordion section."
      },
      "attribute": "detached",
      "reflect": false,
      "defaultValue": "false"
    },
    "rounded": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Applies rounded corners."
      },
      "attribute": "rounded",
      "reflect": false,
      "defaultValue": "false"
    },
    "single": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "When set to true, an open accordion element closes, if anthorer one opens."
      },
      "attribute": "single",
      "reflect": false,
      "defaultValue": "false"
    },
    "tone": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'dark'",
        "resolved": "\"dark\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Use `'dark'` on white backgrounds. Default is a light tone.\nTakes only effect in conjunction with neutral mode."
      },
      "attribute": "tone",
      "reflect": false
    }
  }; }
  static get elementRef() { return "el"; }
  static get listeners() { return [{
      "name": "ldaccordionchange",
      "method": "handleAccordionExpandChange",
      "target": undefined,
      "capture": false,
      "passive": true
    }]; }
}
