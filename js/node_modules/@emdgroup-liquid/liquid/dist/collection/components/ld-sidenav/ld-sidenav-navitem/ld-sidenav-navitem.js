import { Component, Element, Event, h, Listen, Method, Prop, State, } from '@stencil/core';
import { getClassNames } from '../../../utils/getClassNames';
import { closest } from '../../../utils/closest';
import { toggleStackToTop } from '../utils/toggleStackToTop';
/**
 * @slot - default slot for the nav item label.
 * @slot icon - slot for svg or icon component.
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdSidenavNavitem {
  constructor() {
    /** Sets visual indicator to denote that the nav item is currently selected. */
    this.selected = false;
    /** Applies full border-radius. */
    this.rounded = false;
    this.getabbreviation = () => {
      try {
        const words = this.el.textContent.trim().split(' ');
        const chars = words.length > 1
          ? words.map((s) => {
            const char = s.match(/[a-zA-Z]/);
            return (char && char[0]) || '';
          })
          : words[0].match(/[a-zA-Z]/g);
        return chars
          .filter((c) => c)
          .slice(0, 2)
          .join('')
          .toUpperCase();
      }
      catch (err) {
        return '';
      }
    };
    this.onClick = () => {
      var _a;
      if (this.to) {
        // Trigger navigation to subnav.
        this.ldSidenavNavitemTo.emit({ id: this.to, label: this.el.textContent });
      }
      else if (this.el.parentElement.tagName === 'LD-SIDENAV-ACCORDION') {
        // Expand accordion.
        if (this.expandOnClick !== false && this.sidenavCollapsed) {
          ;
          this.el.parentElement.expanded =
            true;
        }
      }
      this.ldSidenavNavitemClick.emit();
      (_a = this.tooltipRef) === null || _a === void 0 ? void 0 : _a.hideTooltip();
      // Expand sidenav.
      if (this.expandOnClick ||
        ((this.to || this.el.parentElement.tagName === 'LD-SIDENAV-ACCORDION') &&
          this.expandOnClick !== false)) {
        this.sidenav.collapsed = false;
      }
    };
    // We need to have an explicit keydown handler for keyboard navigation
    // since we do not use click events (see comment above).
    this.onKeyDown = (ev) => {
      if ([' ', 'Enter'].includes(ev.key)) {
        if (this.to) {
          ev.preventDefault();
        }
        this.onClick();
      }
    };
    this.updateTooltipIcon = () => {
      var _a;
      const themeEl = this.el.closest('[class*="ld-theme-"]');
      if (!themeEl)
        return;
      // Array.from(themeEl.classList).find doesn't work in JSDom.
      this.themeClass = themeEl.classList
        .toString()
        .split(' ')
        .find((cl) => cl.startsWith('ld-theme-'));
      this.secondaryIconHTML = (_a = this.el.querySelector('[slot="icon-secondary"]')) === null || _a === void 0 ? void 0 : _a.outerHTML;
    };
  }
  /**
   * Sets focus on the anchor or button
   */
  async focusInner() {
    var _a;
    (_a = this.focusableElement) === null || _a === void 0 ? void 0 : _a.focus();
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    this.sidenavCollapsed = ev.detail.collapsed;
    toggleStackToTop(this.el, this.sidenav.narrow && this.sidenavCollapsed);
    this.tooltipRef.hideTooltip();
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    this.sidenavClosable = ev.detail;
    if (this.sidenavClosable) {
      toggleStackToTop(this.el, false);
    }
    else {
      toggleStackToTop(this.el, this.sidenav.narrow && this.sidenavCollapsed);
    }
  }
  componentWillLoad() {
    this.inAccordion = this.el.parentElement.tagName === 'LD-SIDENAV-ACCORDION';
    this.isAccordionToggle =
      this.inAccordion && this.el.getAttribute('slot') === 'toggle';
    this.sidenav = closest('ld-sidenav', this.el);
    if (this.sidenav) {
      this.sidenavAlignement = this.sidenav.align;
      this.sidenavExpandsOnMouseEnter =
        this.sidenav.expandTrigger === 'mouseenter';
    }
    if (!['secondary', 'tertiary'].includes(this.mode)) {
      this.tooltipContent = this.el.textContent.trim();
      if (!this.el.querySelector('[slot="icon"]')) {
        this.abbreviation = this.getabbreviation();
      }
    }
  }
  componentDidLoad() {
    // HACK: Due to Safari's buggy line-clamp implementation we need
    //  to trigger a re-render after a certain timeout in order for the
    //  ellipsis to be rendered. In most cases the first timeout is enough
    //  to trigger a re-render in Safari. However, in rare cases we need
    //  to wait a little longer.
    //  A re-render can be triggered by changing certain styles; in our
    //  case we use box-sizing and align-items which otherwhise do not
    //  effect the appearence of the element.
    setTimeout(() => {
      this.slotContainerRef.style.boxSizing = 'border-box';
    });
    setTimeout(() => {
      this.slotContainerRef.style.alignItems = 'center';
    }, 200);
  }
  render() {
    const cl = getClassNames([
      'ld-sidenav-navitem',
      this.selected && 'ld-sidenav-navitem--selected',
      this.inAccordion && 'ld-sidenav-navitem--in-accordion',
      this.rounded && 'ld-sidenav-navitem--rounded',
      this.mode && `ld-sidenav-navitem--${this.mode}`,
      this.sidenavAlignement === 'right' && 'ld-sidenav-navitem--right-aligned',
      this.sidenavCollapsed &&
        !this.sidenavClosable &&
        'ld-sidenav-navitem--collapsed',
    ]);
    const Tag = this.href ? 'a' : 'button';
    const tooltipIconStyle = {
      color: 'var(--ld-thm-primary)',
      display: 'inline-flex',
      marginLeft: 'var(--ld-sp-6)',
    };
    const hasPopup = this.to || this.isAccordionToggle ? 'true' : undefined;
    return (h(Tag, { part: "navitem focusable", class: cl, href: this.href, ref: (el) => (this.focusableElement = el), rel: this.target === '_blank' ? 'noreferrer noopener' : undefined, onClick: this.onClick, onKeyDown: this.onKeyDown, "aria-haspopup": hasPopup, tabIndex: this.ldTabindex },
      h("div", { class: "ld-sidenav-navitem__bg", part: "bg" },
        h("div", { class: "ld-sidenav-navitem__bg-left" }),
        h("div", { class: "ld-sidenav-navitem__bg-center" }),
        h("div", { class: "ld-sidenav-navitem__bg-right" })),
      h("div", { class: "ld-sidenav-navitem__dot", part: "dot" }),
      h("div", { class: "ld-sidenav-navitem__slot-container-icon", role: "presentation", part: "slot-container-icon" },
        h("slot", { name: "icon" }),
        this.abbreviation && (h("span", { class: "ld-sidenav-navitem__abbr", part: "abbreviation" }, this.abbreviation)),
        h("ld-tooltip", { arrow: true, size: "sm", class: "ld-sidenav-navitem__tooltip", disabled: !this.sidenavCollapsed, ref: (el) => (this.tooltipRef = el), "show-delay": "250", onMouseEnter: this.updateTooltipIcon, position: this.sidenavAlignement === 'left' ? 'right middle' : 'left middle', tag: "span" },
          h("div", { class: "ld-sidenav-navitem__tooltip-trigger", slot: "trigger" }),
          h("div", { class: this.themeClass, style: {
              display: 'grid',
              gridAutoFlow: 'column',
              alignItems: 'center',
            } },
            h("ld-typo", null, this.tooltipContent),
            this.to ? (h("ld-icon", { style: tooltipIconStyle, name: "real-arrow" })) : (this.secondaryIconHTML && (h("span", { style: tooltipIconStyle, innerHTML: this.secondaryIconHTML })))))),
      h("div", { class: "ld-sidenav-navitem__slot-container", part: "slot-container", ref: (el) => (this.slotContainerRef = el) },
        h("slot", null)),
      h("div", { class: "ld-sidenav-navitem__slot-icon-secondary-container" }, this.to ? (h("ld-icon", { class: "ld-sidenav-navitem__icon-to", name: "real-arrow" })) : (h("slot", { name: "icon-secondary" })))));
  }
  static get is() { return "ld-sidenav-navitem"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-sidenav-navitem.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-sidenav-navitem.shadow.css"]
  }; }
  static get properties() { return {
    "selected": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Sets visual indicator to denote that the nav item is currently selected."
      },
      "attribute": "selected",
      "reflect": false,
      "defaultValue": "false"
    },
    "href": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Transforms the nav item to an anchor element."
      },
      "attribute": "href",
      "reflect": false
    },
    "mode": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'secondary' | 'tertiary'",
        "resolved": "\"secondary\" | \"tertiary\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Display mode.\nIn secondary mode the navitem is less high, displays a filled dot\ninstead of the icon and is hidden when the sidenav collapses.\nThe tertiary mode is similar to secondary mode, with the navitem\nindented and the dot being empty and having a border."
      },
      "attribute": "mode",
      "reflect": false
    },
    "rounded": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Applies full border-radius."
      },
      "attribute": "rounded",
      "reflect": true,
      "defaultValue": "false"
    },
    "ldTabindex": {
      "type": "number",
      "mutable": false,
      "complexType": {
        "original": "number | undefined",
        "resolved": "number",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Tab index of the button."
      },
      "attribute": "ld-tabindex",
      "reflect": false
    },
    "expandOnClick": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "By default, the sidenav automatically expands on click of a navitem,\nwhich has a `to` property or acts as an accordion toggle. You can\noverwrite this behavior by using this prop to explicitly force or\nprevent expansion of the sidenav."
      },
      "attribute": "expand-on-click",
      "reflect": false
    },
    "target": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'_blank' | '_self' | '_parent' | '_top'",
        "resolved": "\"_blank\" | \"_parent\" | \"_self\" | \"_top\"",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "The `target` attributed can be used in conjunction with the `href` attribute.\nSee [mdn docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#attr-target)\nfor more information on the `target` attribute."
      },
      "attribute": "target",
      "reflect": false
    },
    "to": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Accepts an id of an ld-subnav component to navigate to it on click."
      },
      "attribute": "to",
      "reflect": true
    }
  }; }
  static get states() { return {
    "tooltipContent": {},
    "abbreviation": {},
    "inAccordion": {},
    "isAccordionToggle": {},
    "sidenavAlignement": {},
    "sidenavClosable": {},
    "sidenavCollapsed": {},
    "sidenavExpandsOnMouseEnter": {},
    "secondaryIconHTML": {},
    "closestTheme": {},
    "themeClass": {}
  }; }
  static get events() { return [{
      "method": "ldSidenavNavitemTo",
      "name": "ldSidenavNavitemTo",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted on click if prop to is set."
      },
      "complexType": {
        "original": "{ id: string; label: string }",
        "resolved": "{ id: string; label: string; }",
        "references": {}
      }
    }, {
      "method": "ldSidenavNavitemClick",
      "name": "ldSidenavNavitemClick",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted on click."
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "focusInner": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "Sets focus on the anchor or button",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get listeners() { return [{
      "name": "ldSidenavCollapsedChange",
      "method": "handleSidenavCollapsedChange",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "ldSidenavBreakpointChange",
      "method": "handleSidenavBreakpointChange",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
