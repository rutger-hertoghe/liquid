import { Component, Element, Event, h, Host, Listen, Method, Prop, State, Watch, } from '@stencil/core';
import { getClassNames } from '../../utils/getClassNames';
import { getFirstFocusable } from '../../utils/focus';
/**
 * @slot - default slot, vertically scrollable.
 * @slot top - slot fixed at the top, above scrollable default slot.
 * @slot bottom - slot fixed at the bottom, below scrollable default slot.
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdSidenav {
  constructor() {
    /** Whether the nav should be aligned to the left or the right side of its container. */
    this.align = 'left';
    /**
     * The breakpoint at which the sidenav takes full width and can be
     * opened and closed as opposed to being expanded and collapsed.
     * The prop value is used in a max-width media query.
     */
    this.breakpoint = '23.4375rem';
    /** Indicates that the navigation is collapsed to the side of its container. */
    this.collapsed = false;
    /**
     * Makes the navigation collapse either on
     * - explicit toggle button click,
     * - when the user clicks somewhere outside the element or
     * - when the user moves the cursor / focus outside the element.
     * The modes are inclusive from right to left:
     * - clickoutside applies if the collapse trigger is set to mouseout
     * - toggle applies if the collapse trigger is set to clickoutside
     */
    this.collapseTrigger = 'toggle';
    /**
     * Allows the side navigation to be collapsed to the side of its container.
     */
    this.collapsible = false;
    /**
     * Makes the navigation expand either on
     * - explicit toggle button click,
     * - when the user moves the cursor over the element.
     * The modes are inclusive from right to left:
     * - toggle applies if the expand trigger is set to mouseenter
     */
    this.expandTrigger = 'toggle';
    /** Label to be used for the landmark element (the sidenav itself). */
    this.label = 'Side navigation';
    /**
     * Set to true if you'd like to have a sidenav which partially
     * collapses in way, that slotted ld-navitem components are displayed
     * as icon buttons.
     */
    this.narrow = false;
    /**
     * Indicates that the navigation is visible in a viewport
     * which is smaller than the value of the `breakpoint` prop.
     */
    this.open = false;
    /**
     * Disables transitions on collapsing and expansion of the sidenav.
     * This is especially usefull when the page content gets pushed to
     * the side on sidenav expansion, and you want to prevent too many
     * layout shifts during the transition.
     */
    this.toggleTransitionDisabled = false;
    this.fullyCollapsible = false;
    this.hasActiveSubnav = false;
    this.hasShadowBottom = false;
    this.hasShadowTop = false;
    this.transitions = false;
    this.toFocus = undefined;
    this.focusTimeout = undefined;
    this.updateFocus = () => {
      // HACK: Using recursive call with timeout to account for fast user interactions during transitions.
      clearTimeout(this.focusTimeout);
      if (this.toFocus) {
        if (this.toFocus.tabIndex === -1 ||
          window.getComputedStyle(this.toFocus).visibility === 'hidden') {
          this.focusTimeout = setTimeout(this.updateFocus, 10);
          return;
        }
        this.toFocus.focus();
        this.toFocus = undefined;
      }
    };
    this.toggleCollapsedState = () => {
      this.collapsed = !this.collapsed;
    };
    this.activeSubnavContainsIcons = () => {
      const slider = this.el.querySelector('ld-sidenav-slider');
      const activeSubnav = slider.currentSubnav
        ? this.el.querySelector(`#${slider.currentSubnav}`)
        : slider;
      const navitemsModePrimaryChildren = Array.from(activeSubnav.children).filter((child) => child.tagName === 'LD-SIDENAV-NAVITEM' &&
        !child.mode);
      const navitemsModePrimaryInAccordion = Array.from(activeSubnav.querySelectorAll('ld-sidenav-accordion > ld-sidenav-navitem[slot="toggle"]')).filter((child) => !child.mode);
      const totalNavitemsModePrimary = navitemsModePrimaryChildren.length + navitemsModePrimaryInAccordion.length;
      return !!totalNavitemsModePrimary;
    };
    this.isToggleOutside = (element) => (element === null || element === void 0 ? void 0 : element.tagName) === 'LD-SIDENAV-TOGGLE-OUTSIDE';
    this.onTransitionEnd = (ev) => {
      if (ev.target === this.el) {
        this.transitions = true;
        // If the sidenav was fully collapsed and is being expanded, set the focus
        // on the first focusable element. If it is being collapsed, set the focus
        // on the toggle outside if it is there.
        if (this.fullyCollapsible) {
          if (!this.collapsed) {
            const firstFocusableInSidenav = getFirstFocusable(this.el);
            firstFocusableInSidenav.focus();
          }
          else {
            const previousElementSibling = this.el.previousElementSibling;
            if (this.isToggleOutside(previousElementSibling)) {
              previousElementSibling.focusInner();
            }
          }
        }
      }
    };
    this.onMatchMediaChange = (ev) => {
      this.closable = ev.matches;
      // Remove transitions class on breakpoint change in order to prevent
      // weird looking transitions on screen resize or orientation change events.
      // Add it back on transition end / after style changes have been applied.
      this.transitions = false;
      // When there is less space available than before the breakpoint change,
      // collapse the side nav if it is collapsible.
      if (this.closable && this.collapsible)
        this.collapsed = true;
      this.ldSidenavBreakpointChange.emit(this.closable);
    };
  }
  /**
   * Toggles sidenav.
   */
  async toggle() {
    if (this.closable) {
      this.open = !this.open;
    }
    else {
      this.toggleCollapsedState();
    }
  }
  onCollapsedChange(collapsed) {
    // The ldSidenavCollapsedChange event needs to be emitted even if the
    // sidenav is currently not collapsible (when it is closable), because
    // on breakpoint change its subcomponents need to be rendered according
    // to the new state and thus need to update their state using the event.
    this.ldSidenavCollapsedChange.emit({
      collapsed,
      fully: this.fullyCollapsible,
    });
    if (collapsed) {
      this.open = false;
    }
  }
  onOpenChange(open) {
    this.ldSidenavOpenChange.emit(open);
    if (!open && this.collapsible) {
      this.collapsed = true;
    }
  }
  updateFullyCollapsible() {
    this.fullyCollapsible =
      this.collapsible && (!this.narrow || !this.activeSubnavContainsIcons());
  }
  handleClickOutside(ev) {
    if (['clickoutside', 'mouseout'].includes(this.collapseTrigger) &&
      ev.target.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseOut(ev) {
    if (this.collapseTrigger === 'mouseout' &&
      ev.relatedTarget &&
      ev.relatedTarget.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseIn() {
    if (this.fullyCollapsible || this.expandTrigger === 'mouseenter') {
      this.collapsed = false;
    }
  }
  handleOpen() {
    this.open = true;
  }
  handleClose() {
    clearTimeout(this.focusTimeout);
    this.open = false;
  }
  handleSlideBack() {
    clearTimeout(this.focusTimeout);
    const currentSubnav = Array.from(this.el.querySelectorAll('.ld-sidenav-subnav--active')).pop();
    const currentSubnavId = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.id;
    const parentSubnav = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.parentElement;
    this.el.querySelector('ld-sidenav-slider').navigateBack();
    // Set focus on parent nav-item element as soon as back button looses focus.
    this.toFocus = parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.querySelector(`[to='${currentSubnavId}']`).shadowRoot.querySelector('[part*="focusable"]');
    // Always expand side navigation on back button click.
    this.collapsed = false;
  }
  slideToHandler() {
    var _a;
    clearTimeout(this.focusTimeout);
    // set focus on back button
    const ldSidenavBack = (_a = this.el
      .querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.shadowRoot.querySelector('.ld-sidenav-back');
    this.toFocus = ldSidenavBack;
    this.updateFocus();
  }
  slideChangeHandler(ev) {
    var _a, _b;
    clearTimeout(this.focusTimeout);
    (_a = this.el.querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.updateLabel((_b = ev.detail) === null || _b === void 0 ? void 0 : _b.label);
    this.hasActiveSubnav = !!ev.detail;
    this.updateFullyCollapsible();
    this.updateFocus();
  }
  handleKeyDown(ev) {
    // Ignore events if sidenav has no focus and is not closable.
    const hasSidenavFocus = document.activeElement.closest('ld-sidenav') === this.el;
    if (hasSidenavFocus &&
      ev.key === 'Tab' &&
      !ev.shiftKey &&
      document.activeElement === this.el.querySelector('ld-sidenav-back')) {
      // This block prevents the focus from being set to the wrong element,
      // when a user quickly hits the [Tab] key after triggering the
      // transition to a subnav.
      const { currentSubnav } = this.el.querySelector('ld-sidenav-slider');
      if (currentSubnav) {
        const firstItemOfCurrentSubnav = getFirstFocusable(this.el.querySelector(`#${currentSubnav}`));
        setTimeout(async () => {
          if ('focusInner' in firstItemOfCurrentSubnav) {
            await firstItemOfCurrentSubnav.focusInner();
          }
          else {
            firstItemOfCurrentSubnav.focus();
          }
        });
      }
    }
    if (!hasSidenavFocus && !this.closable) {
      return;
    }
    const slider = this.el.querySelector('ld-sidenav-slider');
    if (ev.key === 'Escape') {
      if (!slider && this.closable) {
        this.open = false;
        return;
      }
      if (this.hasActiveSubnav) {
        this.handleSlideBack();
      }
      else if (this.closable) {
        this.open = false;
      }
    }
  }
  async handleFocusout(ev) {
    const relatedTarget = ev.relatedTarget;
    const isFocusInSidenav = (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest('ld-sidenav')) === this.el;
    // If focus is outside the sidenav and the collapse trigger is set
    // to 'mouseout', collapse the sidenav.
    if (!isFocusInSidenav && relatedTarget !== null) {
      if (this.collapseTrigger === 'mouseout') {
        this.collapsed = this.collapsible;
      }
    }
    // If focus is inside the sidenav expand the sidenav.
    if (this.expandTrigger === 'mouseenter' && isFocusInSidenav) {
      this.collapsed = false;
    }
    // If the sidenav is closable, trap the focus.
    // Do not trap the focus as long as the sidenav is not closable or not open.
    if (!this.closable || !this.open)
      return;
    // Do not trap the focus if the trap focus prop is not set.
    if (this.trapFocus === undefined)
      return;
    // Do not trap the focus as long as the focus remains within the sidenav.
    if (isFocusInSidenav)
      return;
    // Do not trap the focus when it moves to an element which matches
    // the trap focus selector or no element will be focused.
    const isFocusInKeepFocusable = this.trapFocus !== '' &&
      (!relatedTarget || (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.matches(this.trapFocus)));
    if (isFocusInKeepFocusable)
      return;
    // Loop the focus between the ld-sidenav and the elements matching
    // the trap focus selector.
    const target = ev.target;
    const isLeavingSidenav = target.closest('ld-sidenav') === this.el;
    const isLeavingFocusSelectorElement = this.trapFocus !== '' && !!target.closest(this.trapFocus);
    if (!isLeavingSidenav && !isLeavingFocusSelectorElement)
      return;
    const firstFocusableInSidenav = getFirstFocusable(this.el);
    const trapFocusSelectorElements = this.trapFocus === ''
      ? [firstFocusableInSidenav]
      : Array.from(document.querySelectorAll(this.trapFocus));
    const firstFocusableFromSelectorElements = trapFocusSelectorElements.find(getFirstFocusable);
    const isLeavingFirstFocusableInSidenav = firstFocusableInSidenav === target;
    const isLeavingFirstFocusableFromSelectorElements = firstFocusableFromSelectorElements === target;
    const lastFocusableInSidenav = Array.from(this.el.querySelectorAll('*'))
      .reverse()
      .find(getFirstFocusable);
    const lastFocusableFromSelectorElements = trapFocusSelectorElements
      .reverse()
      .find(getFirstFocusable);
    const nextFocused = isLeavingSidenav
      ? isLeavingFirstFocusableInSidenav
        ? lastFocusableFromSelectorElements
        : firstFocusableFromSelectorElements
      : isLeavingFirstFocusableFromSelectorElements
        ? lastFocusableInSidenav
        : firstFocusableInSidenav;
    if (!nextFocused)
      return;
    if ('focusInner' in nextFocused) {
      await nextFocused.focusInner();
    }
    else {
      nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.focus();
    }
  }
  handleHeaderToggleClick() {
    this.toggle();
  }
  componentWillLoad() {
    this.mediaQuery = window.matchMedia(`(max-width: ${this.breakpoint})`);
    this.mediaQuery.addEventListener('change', this.onMatchMediaChange);
    this.closable = this.mediaQuery.matches;
    this.updateFullyCollapsible();
  }
  componentDidLoad() {
    this.ldSidenavCollapsedChange.emit({
      collapsed: this.collapsible && this.collapsed,
      fully: this.fullyCollapsible,
    });
    this.ldSidenavOpenChange.emit(this.open);
    this.ldSidenavBreakpointChange.emit(this.closable);
    setTimeout(() => {
      this.transitions = true;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mediaQuery) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this.onMatchMediaChange);
  }
  render() {
    const cl = [
      'ld-sidenav',
      this.align === 'right' && 'ld-sidenav--right',
      this.transitions && 'ld-sidenav--transitions',
      this.closable && 'ld-sidenav--closable',
      this.collapsible && this.collapsed && 'ld-sidenav--collapsed',
      this.collapsible && 'ld-sidenav--collapsible',
      this.fullyCollapsible && 'ld-sidenav--fully-collapsible',
      this.hasActiveSubnav && 'ld-sidenav--has-active-subnav',
      this.hasShadowTop && 'ld-sidenav--has-shadow-top',
      this.hasShadowBottom && 'ld-sidenav--has-shadow-bottom',
      this.open && 'ld-sidenav--open',
      this.toggleTransitionDisabled && 'ld-sidenav--toggle-transition-disabled',
    ];
    return (h(Host, { onTransitionEnd: this.onTransitionEnd, class: getClassNames(cl), role: "navigation", "aria-label": this.label },
      h("slot", { name: "header" }),
      h("div", { class: "ld-sidenav__content" },
        h("div", { class: "ld-sidenav__slot-container-top", part: "slot-container-top" },
          h("slot", { name: "top" })),
        h("ld-sidenav-scroller-internal", { class: "ld-sidenav__scroller", part: "scroll-container" },
          h("div", { class: "ld-sidenav__slot-container-default", part: "slot-container" },
            h("slot", null))),
        h("div", { class: "ld-sidenav__slot-container-bottom", part: "slot-container-bottom" },
          h("slot", { name: "bottom" }))),
      h("div", { onClick: this.toggle.bind(this), class: "ld-sidenav__fully-collapsed-click-area" })));
  }
  static get is() { return "ld-sidenav"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-sidenav.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-sidenav.shadow.css"]
  }; }
  static get properties() { return {
    "align": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'left' | 'right'",
        "resolved": "\"left\" | \"right\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Whether the nav should be aligned to the left or the right side of its container."
      },
      "attribute": "align",
      "reflect": false,
      "defaultValue": "'left'"
    },
    "breakpoint": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "The breakpoint at which the sidenav takes full width and can be\nopened and closed as opposed to being expanded and collapsed.\nThe prop value is used in a max-width media query."
      },
      "attribute": "breakpoint",
      "reflect": false,
      "defaultValue": "'23.4375rem'"
    },
    "collapsed": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Indicates that the navigation is collapsed to the side of its container."
      },
      "attribute": "collapsed",
      "reflect": false,
      "defaultValue": "false"
    },
    "collapseTrigger": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'toggle' | 'clickoutside' | 'mouseout'",
        "resolved": "\"clickoutside\" | \"mouseout\" | \"toggle\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Makes the navigation collapse either on\n- explicit toggle button click,\n- when the user clicks somewhere outside the element or\n- when the user moves the cursor / focus outside the element.\nThe modes are inclusive from right to left:\n- clickoutside applies if the collapse trigger is set to mouseout\n- toggle applies if the collapse trigger is set to clickoutside"
      },
      "attribute": "collapse-trigger",
      "reflect": false,
      "defaultValue": "'toggle'"
    },
    "collapsible": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Allows the side navigation to be collapsed to the side of its container."
      },
      "attribute": "collapsible",
      "reflect": false,
      "defaultValue": "false"
    },
    "expandTrigger": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'toggle' | 'mouseenter'",
        "resolved": "\"mouseenter\" | \"toggle\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Makes the navigation expand either on\n- explicit toggle button click,\n- when the user moves the cursor over the element.\nThe modes are inclusive from right to left:\n- toggle applies if the expand trigger is set to mouseenter"
      },
      "attribute": "expand-trigger",
      "reflect": false,
      "defaultValue": "'toggle'"
    },
    "label": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Label to be used for the landmark element (the sidenav itself)."
      },
      "attribute": "label",
      "reflect": false,
      "defaultValue": "'Side navigation'"
    },
    "narrow": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Set to true if you'd like to have a sidenav which partially\ncollapses in way, that slotted ld-navitem components are displayed\nas icon buttons."
      },
      "attribute": "narrow",
      "reflect": false,
      "defaultValue": "false"
    },
    "open": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Indicates that the navigation is visible in a viewport\nwhich is smaller than the value of the `breakpoint` prop."
      },
      "attribute": "open",
      "reflect": false,
      "defaultValue": "false"
    },
    "toggleTransitionDisabled": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Disables transitions on collapsing and expansion of the sidenav.\nThis is especially usefull when the page content gets pushed to\nthe side on sidenav expansion, and you want to prevent too many\nlayout shifts during the transition."
      },
      "attribute": "toggle-transition-disabled",
      "reflect": false,
      "defaultValue": "false"
    },
    "trapFocus": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Enables focus trapping. Accespts a CSS selector which indicates\nwhat is still focusable outside the sidenav, when the sidenav is\nclosable and open (i.e. \"ld-header *\"). Use an empty string to\nenable focus trapping without specifying focusable elements\noutside the sidenav component."
      },
      "attribute": "trap-focus",
      "reflect": false
    }
  }; }
  static get states() { return {
    "closable": {},
    "fullyCollapsible": {},
    "hasActiveSubnav": {},
    "hasShadowBottom": {},
    "hasShadowTop": {},
    "transitions": {}
  }; }
  static get events() { return [{
      "method": "ldSidenavCollapsedChange",
      "name": "ldSidenavCollapsedChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav collapses or expands."
      },
      "complexType": {
        "original": "{\n    collapsed: boolean\n    fully: boolean\n  }",
        "resolved": "{ collapsed: boolean; fully: boolean; }",
        "references": {}
      }
    }, {
      "method": "ldSidenavOpenChange",
      "name": "ldSidenavOpenChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav opens or closes."
      },
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      }
    }, {
      "method": "ldSidenavBreakpointChange",
      "name": "ldSidenavBreakpointChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav registers a match media change event."
      },
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "toggle": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "Toggles sidenav.",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "collapsed",
      "methodName": "onCollapsedChange"
    }, {
      "propName": "open",
      "methodName": "onOpenChange"
    }, {
      "propName": "collapsible",
      "methodName": "updateFullyCollapsible"
    }, {
      "propName": "narrow",
      "methodName": "updateFullyCollapsible"
    }]; }
  static get listeners() { return [{
      "name": "click",
      "method": "handleClickOutside",
      "target": "window",
      "capture": false,
      "passive": false
    }, {
      "name": "mouseout",
      "method": "handleMouseOut",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "mouseenter",
      "method": "handleMouseIn",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "ldSidenavOpen",
      "method": "handleOpen",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavClose",
      "method": "handleClose",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavBack",
      "method": "handleSlideBack",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavNavitemTo",
      "method": "slideToHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavSliderChange",
      "method": "slideChangeHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "keydown",
      "method": "handleKeyDown",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "focusout",
      "method": "handleFocusout",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "ldSidenavHeaderToggleClick",
      "method": "handleHeaderToggleClick",
      "target": undefined,
      "capture": false,
      "passive": false
    }]; }
}
