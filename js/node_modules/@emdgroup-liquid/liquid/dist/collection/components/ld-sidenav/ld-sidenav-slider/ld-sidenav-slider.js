import { Component, Element, Event, h, Host, Listen, Method, Prop, State, Watch, } from '@stencil/core';
import { getClassNames } from '../../../utils/getClassNames';
import { closest } from '../../../utils/closest';
/**
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdSidenavSlider {
  constructor() {
    this.activeSubnavs = [];
    this.isFirstLevelHidden = false;
    this.updateActiveBeforeTransition = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.activeBeforeTransition = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.activeBeforeTransition = true;
      });
    };
    this.updateActive = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.active = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.active = true;
      });
    };
    this.updateAncestor = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.ancestor = false;
      });
      // update
      this.activeSubnavs.forEach((subnav, index) => {
        subnav.ancestor = index < this.activeSubnavs.length - 1;
      });
    };
    this.updateFirstLevelHidden = () => {
      this.isFirstLevelHidden = this.currentNavLevel > 0;
    };
    this.scrollInactiveToTop = () => {
      // Scroll all inactive subnav scroll containers to top.
      Array.from(this.el.querySelectorAll('ld-sidenav-subnav')).forEach((subnav) => {
        if (!subnav.active) {
          subnav.scrollToTop();
        }
      });
    };
    this.onTransitionEnd = (ev) => {
      if (ev.target !== this.el)
        return;
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    };
    this.toggleVisibilityOnHidableContent = (visible) => {
      Array.from(this.el.children).forEach((el) => {
        // To also hide one of the following elements,
        // it is possible to wrap it in a div with display contents.
        if (![
          'LD-SIDENAV-ACCORDION',
          'LD-SIDENAV-NAVITEM',
          'LD-SIDENAV-SEPARATOR',
          'LD-SIDENAV-SUBNAV',
        ].includes(el.tagName)) {
          el.classList.toggle('ld-sidenav-slider__hidden', !visible);
        }
      });
    };
  }
  navigateToSubnav() {
    // Make current subnav and all ancestor subnavs active.
    let parentSubnav;
    let subnavId = this.currentSubnav;
    this.activeSubnavs = [];
    while (subnavId) {
      const subnav = document.querySelector(`#${subnavId}`);
      if (subnav) {
        subnav.active = true;
        parentSubnav = subnav.closest(`ld-sidenav-subnav:not(#${subnavId})`);
        this.activeSubnavs.unshift(subnav);
        if (parentSubnav) {
          subnavId = parentSubnav.id;
        }
        else {
          subnavId = undefined;
        }
      }
      else {
        subnavId = undefined;
      }
    }
    if (this.activeSubnavs.length !== this.currentNavLevel) {
      // Condition is true for almost all use cases.
      let needsInertUpdate = false;
      if (this.currentNavLevel === undefined ||
        this.currentNavLevel > this.activeSubnavs.length) {
        needsInertUpdate = true;
        this.updateAncestor();
      }
      this.currentNavLevel = this.activeSubnavs.length;
      if (needsInertUpdate)
        this.updateFirstLevelHidden();
      this.updateActiveBeforeTransition();
    }
    else if (this.activeSubnavs.length > 0) {
      // This condition applies if navigating to a subnav
      // which has the same level as the currently active subnav.
      // This happens on change of the currentSubnav prop from
      // the outside.
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    }
  }
  handleSubnavChange() {
    this.navigateToSubnav();
    this.emitChange();
  }
  slideToHandler(ev) {
    this.currentSubnav = ev.detail.id;
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    if (ev.detail.collapsed) {
      this.scrollerRef.scrollToTop(true);
      this.toggleVisibilityOnHidableContent(false);
    }
    else {
      this.toggleVisibilityOnHidableContent(true);
    }
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    const sidenavClosable = ev.detail;
    if (sidenavClosable) {
      this.toggleVisibilityOnHidableContent(true);
    }
    else {
      this.toggleVisibilityOnHidableContent(!this.sidenav.collapsed);
    }
  }
  /** Navigates back to the parent nav. */
  async navigateBack() {
    if (this.currentNavLevel > 0) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2];
      this.currentSubnav = (parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.id) || '';
    }
  }
  emitChange() {
    const activeSubnav = this.activeSubnavs[this.activeSubnavs.length - 1];
    if (activeSubnav) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2] || this.el;
      this.ldSidenavSliderChange.emit({
        id: activeSubnav.id,
        label: parentSubnav.label,
      });
    }
    else if (!this.currentSubnav) {
      this.ldSidenavSliderChange.emit();
    }
  }
  componentWillLoad() {
    this.sidenav = closest('ld-sidenav', this.el);
    if (this.currentSubnav) {
      this.handleSubnavChange();
    }
    if (this.currentNavLevel === undefined) {
      this.currentNavLevel = 0;
    }
  }
  render() {
    const cl = getClassNames([
      'ld-sidenav-slider',
      this.currentNavLevel > 0 && 'ld-sidenav-slider--subnav-active',
    ]);
    return (h(Host, { onTransitionEnd: this.onTransitionEnd, class: cl, style: {
        transform: `translateX(-${this.currentNavLevel}00%)`,
        visibility: this.isFirstLevelHidden ? 'hidden' : 'inherit',
      } },
      h("ld-sidenav-scroller-internal", { part: "scroll-container", ref: (el) => (this.scrollerRef = el) },
        h("slot", null))));
  }
  static get is() { return "ld-sidenav-slider"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-sidenav-slider.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-sidenav-slider.shadow.css"]
  }; }
  static get properties() { return {
    "currentSubnav": {
      "type": "string",
      "mutable": true,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "ID of the subnav that shall be shown on initial render."
      },
      "attribute": "current-subnav",
      "reflect": false
    },
    "label": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Used in the ld-sidenav-back component to display parent nav label."
      },
      "attribute": "label",
      "reflect": false
    }
  }; }
  static get states() { return {
    "currentNavLevel": {},
    "activeSubnavs": {},
    "isFirstLevelHidden": {}
  }; }
  static get events() { return [{
      "method": "ldSidenavSliderChange",
      "name": "ldSidenavSliderChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted on navigation (before transition ends)."
      },
      "complexType": {
        "original": "{ id: string; label: string } | undefined",
        "resolved": "{ id: string; label: string; }",
        "references": {}
      }
    }]; }
  static get methods() { return {
    "navigateBack": {
      "complexType": {
        "signature": "() => Promise<void>",
        "parameters": [],
        "references": {
          "Promise": {
            "location": "global"
          }
        },
        "return": "Promise<void>"
      },
      "docs": {
        "text": "Navigates back to the parent nav.",
        "tags": []
      }
    }
  }; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "currentSubnav",
      "methodName": "handleSubnavChange"
    }]; }
  static get listeners() { return [{
      "name": "ldSidenavNavitemTo",
      "method": "slideToHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavCollapsedChange",
      "method": "handleSidenavCollapsedChange",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "ldSidenavBreakpointChange",
      "method": "handleSidenavBreakpointChange",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
