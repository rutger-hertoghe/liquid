import { Component, h, Host, Listen, Prop, State, Watch } from '@stencil/core';
const DEFAULT_NOTIFICATION_TIMEOUT = 6000;
const FADE_TRANSITION_DURATION = 200;
export class LdNotification {
  constructor() {
    /**
     * Notification placement within the screen.
     */
    this.placement = 'top';
    this.queue = [];
    this.queueDismissed = [];
    this.fadeoutTimeouts = [];
  }
  updateDismissTimeout() {
    clearTimeout(this.dismissTimeout);
    if (!this.currentNotification)
      return;
    if (this.currentNotification.type === 'alert')
      return;
    if (this.currentNotification.timeout === 0)
      return;
    this.dismissTimeout = setTimeout(() => {
      this.handleNotificationDismiss();
    }, this.currentNotification.timeout || DEFAULT_NOTIFICATION_TIMEOUT);
  }
  handleNotification(ev) {
    ev.stopImmediatePropagation();
    const newNotification = ev.detail;
    // If the same notification is already in queue (same content, same type), ignore this notification.
    const inQueue = this.queue.some((notification) => notification.content === newNotification.content &&
      notification.type === newNotification.type);
    if (inQueue)
      return;
    // Insert by relevance, whith error notifications being more relevant than non-error notifications.
    if (newNotification.type === 'alert') {
      this.queue = [...this.queue, newNotification];
      this.currentNotification = newNotification;
      return;
    }
    const firstErrorNotificationIndex = this.queue.findIndex((notification) => notification.type === 'alert');
    if (firstErrorNotificationIndex === -1) {
      this.queue = [...this.queue, newNotification];
      this.currentNotification = newNotification;
      return;
    }
    this.queue.splice(firstErrorNotificationIndex, 0, newNotification);
    this.queue = [...this.queue];
  }
  handleNotificationDismiss() {
    if (!this.currentNotification)
      return;
    this.queueDismissed.unshift(this.queue.pop());
    this.queueDismissed = [...this.queueDismissed];
    this.queue = [...this.queue];
    this.currentNotification = this.queue[this.queue.length - 1];
    this.fadeoutTimeouts.push(setTimeout(() => {
      this.queueDismissed = this.queueDismissed.slice(0, -1);
    }, FADE_TRANSITION_DURATION));
  }
  handleNotificationClear() {
    this.queueDismissed = [...this.queue];
    this.queue = [];
    this.currentNotification = undefined;
    this.fadeoutTimeouts.forEach(clearTimeout);
    this.fadeoutTimeouts.push(setTimeout(() => {
      this.queueDismissed = [];
    }, FADE_TRANSITION_DURATION));
  }
  renderNotification(notification, dismissed = false) {
    let cl = `ld-notification__item ld-notification__item--${notification.type}`;
    if (dismissed)
      cl += ' ld-notification__item--dismissed';
    return (h("div", { class: cl, key: notification.type + notification.content, part: "item" },
      h("div", { class: "ld-notification__item-content", innerHTML: notification.content, role: notification.type === 'alert' ? 'alert' : 'status', part: "content" }),
      h("button", { class: "ld-notification__btn-dismiss", onClick: dismissed ? undefined : this.handleNotificationDismiss.bind(this), part: "btn-dismiss focusable" },
        h("svg", { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", part: "btn-dismiss-icon" },
          h("title", null, "Dismiss"),
          h("path", { d: "M6 6L18 18", stroke: "currentColor", "stroke-width": "3", "stroke-linecap": "round", "stroke-linejoin": "round" }),
          h("path", { d: "M6 18L18 6", stroke: "currentColor", "stroke-width": "3", "stroke-linecap": "round", "stroke-linejoin": "round" })))));
  }
  disconnectedCallback() {
    clearTimeout(this.dismissTimeout);
    this.fadeoutTimeouts.forEach(clearTimeout);
  }
  render() {
    const cl = `ld-notification ld-notification--${this.placement}`;
    return (h(Host, { class: cl, role: "region", "aria-label": "Notifications" },
      this.queue.map((notification) => this.renderNotification.call(this, notification)),
      this.queueDismissed.map((notification) => this.renderNotification.call(this, notification, true))));
  }
  static get is() { return "ld-notification"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-notification.shadow.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-notification.shadow.css"]
  }; }
  static get properties() { return {
    "placement": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'top' | 'bottom'",
        "resolved": "\"bottom\" | \"top\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Notification placement within the screen."
      },
      "attribute": "placement",
      "reflect": false,
      "defaultValue": "'top'"
    }
  }; }
  static get states() { return {
    "queue": {},
    "queueDismissed": {},
    "dismissTimeout": {},
    "fadeoutTimeouts": {},
    "currentNotification": {}
  }; }
  static get watchers() { return [{
      "propName": "currentNotification",
      "methodName": "updateDismissTimeout"
    }]; }
  static get listeners() { return [{
      "name": "ldNotificationAdd",
      "method": "handleNotification",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "ldNotificationDismiss",
      "method": "handleNotificationDismiss",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "ldNotificationClear",
      "method": "handleNotificationClear",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
