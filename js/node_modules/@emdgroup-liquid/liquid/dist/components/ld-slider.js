import { proxyCustomElement, HTMLElement, createEvent, h, Host, Fragment } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { d as defineCustomElement$2 } from './ld-sr-only2.js';

const ldSliderShadowCss = ":host{--ld-slider-disabled-thumb-box-shadow:0 0 0 #0000;--ld-slider-thumb-box-shadow:var(--ld-slider-thumb-box-shadow-default);--ld-slider-thumb-box-shadow-default:var(--ld-shadow-stacked);--ld-slider-thumb-box-shadow-active:var(--ld-slider-thumb-box-shadow-default),0 0 0 var(--ld-sp-6) var(--ld-thm-primary-alpha-lowest);--ld-slider-thumb-box-shadow-hover:var(--ld-slider-thumb-box-shadow-default),0 0 0 var(--ld-sp-4) var(--ld-thm-primary-alpha-lowest);--ld-slider-thumb-size:var(--ld-slider-thumb-size-md);--ld-slider-thumb-size-sm:var(--ld-sp-24);--ld-slider-thumb-size-md:var(--ld-sp-32);--ld-slider-thumb-size-lg:var(--ld-sp-40);--ld-slider-diff:calc(var(--max) - var(--min));--ld-slider-indicator-size:var(--ld-sp-6);--ld-slider-track-margin:calc((var(--ld-slider-thumb-size) - var(--ld-slider-indicator-size))/2 - 0.0625rem);--ld-slider-radius:calc(var(--ld-slider-thumb-size)/2);--ld-slider-useful-width:calc(var(--ld-slider-width) - var(--ld-slider-thumb-size));--ld-slider-thumb-col:var(--ld-col-wht);--ld-slider-disabled-thumb-col:var(--ld-col-neutral-200);--ld-slider-selected-col:var(--ld-slider-selected-col-default);--ld-slider-selected-col-default:var(--ld-thm-primary);--ld-slider-disabled-selected-col:var(--ld-col-neutral-200);--ld-slider-animation-duration:0s}@media (prefers-reduced-motion:no-preference){:host{--ld-slider-animation-duration:0.15s}}:host{display:grid;font:var(--ld-typo-body-xs);grid-template-rows:max-content var(--ld-slider-thumb-size) max-content;min-width:var(--ld-slider-width);pointer-events:none;position:relative;width:var(--ld-slider-width);z-index:0}:host:after,:host:before{align-self:center;background:var(--ld-col-neutral-100);border-radius:var(--ld-slider-radius);content:\"\";grid-column:1;grid-row:2;height:var(--ld-sp-8);margin:0 var(--ld-slider-track-margin);will-change:transform}:host:after{background:var(--ld-slider-selected-col);cursor:pointer;-webkit-mask:var(--fill);mask:var(--fill);-webkit-mask-composite:xor;mask-composite:exclude;pointer-events:auto}:host([aria-disabled=true]),:host([disabled]){--ld-slider-selected-col:var(--ld-slider-disabled-selected-col);--ld-slider-thumb-box-shadow-default:var(\n      --ld-slider-disabled-thumb-box-shadow\n    );--ld-slider-thumb-col:var(--ld-slider-disabled-thumb-col)}:host([aria-disabled=true]):after,:host([disabled]):after{pointer-events:none}:host([aria-disabled=true]) .ld-slider__input,:host([disabled]) .ld-slider__input{opacity:1}:host([aria-disabled=true]) .ld-slider__input::-webkit-slider-thumb,:host([disabled]) .ld-slider__input::-webkit-slider-thumb{pointer-events:none;transform:scale(.66667)}:host([aria-disabled=true]) .ld-slider__input::-moz-range-thumb,:host([disabled]) .ld-slider__input::-moz-range-thumb{pointer-events:none;transform:scale(.66667)}:host([aria-disabled=true]) .ld-slider__input:focus+.ld-slider__output--permanent:after,:host([disabled]) .ld-slider__input:focus+.ld-slider__output--permanent:after{color:var(--ld-slider-selected-col-default)}:host([aria-disabled=true]) .ld-slider__input:focus:not(:focus-visible)+.ld-slider__output--permanent:after,:host([disabled]) .ld-slider__input:focus:not(:focus-visible)+.ld-slider__output--permanent:after{color:inherit}:host(.ld-slider--padded){padding-bottom:var(--ld-sp-6)}:host(.ld-slider--sm){--ld-slider-thumb-size:var(--ld-slider-thumb-size-sm)}:host(.ld-slider--lg){--ld-slider-thumb-size:var(--ld-slider-thumb-size-lg)}:host *{--ld-slider-highlighted:0;font:inherit;margin:0}:host .ld-slider__input,:host .ld-slider__input::-webkit-slider-runnable-track,:host .ld-slider__input::-webkit-slider-thumb{-webkit-appearance:none}:host .ld-slider__input{background:none;cursor:grab;grid-column:1;grid-row:2;left:0;top:0;z-index:calc(3 + var(--ld-slider-highlighted))}:host .ld-slider__input::-webkit-slider-runnable-track{background:none;height:100%;width:100%}:host .ld-slider__input::-moz-range-track{background:none;height:100%;width:100%;z-index:2}:host .ld-slider__input::-webkit-slider-thumb{background:var(--ld-slider-thumb-col);border:none;border-radius:var(--ld-br-full);box-shadow:var(--ld-slider-thumb-box-shadow);box-sizing:border-box;height:var(--ld-slider-thumb-size);pointer-events:auto;width:var(--ld-slider-thumb-size);will-change:transform}:host .ld-slider__input::-moz-range-thumb{background:var(--ld-slider-thumb-col);border:none;border-radius:var(--ld-br-full);box-shadow:var(--ld-slider-thumb-box-shadow);box-sizing:border-box;height:var(--ld-slider-thumb-size);pointer-events:auto;width:var(--ld-slider-thumb-size);will-change:transform}:host .ld-slider__input:active,:host .ld-slider__input:focus-visible{outline:none}:host .ld-slider__input:active+output,:host .ld-slider__input:focus-visible+output{--ld-slider-highlighted:1}:host .ld-slider__input:focus,:host .ld-slider__input:hover{--ld-slider-thumb-box-shadow:var(--ld-slider-thumb-box-shadow-hover)}:host .ld-slider__input:active{--ld-slider-thumb-box-shadow:var(--ld-slider-thumb-box-shadow-active);cursor:grabbing;outline:none;z-index:4}:host .ld-slider__input:not(:active):not(:focus-visible):not(:hover){--ld-slider-thumb-box-shadow:var(--ld-slider-thumb-box-shadow-default)}:host .ld-slider__indicator,:host .ld-slider__output,:host .ld-slider__value-label{grid-column:1;left:calc((var(--now) - var(--min))/var(--ld-slider-diff)*var(--ld-slider-useful-width) + var(--ld-slider-radius));max-width:max-content;position:relative}:host .ld-slider__indicator{aspect-ratio:1;-webkit-backdrop-filter:brightness(.6) invert(1) hue-rotate(180deg);backdrop-filter:brightness(.6) invert(1) hue-rotate(180deg);border-radius:var(--ld-br-full);grid-row:2;height:var(--ld-slider-indicator-size);opacity:.5;top:var(--ld-slider-radius);transform:translate(-50%,-50%);z-index:1}:host .ld-slider__value-label{grid-row:3;transform:translate(-50%)}:host .ld-slider__value-label--first{left:var(--ld-slider-track-margin);transform:none}:host .ld-slider__value-label--last{left:auto;position:absolute;right:var(--ld-slider-track-margin);transform:none}:host .ld-slider__output{color:var(--ld-col-wht);content:counter(now) var(--unit);counter-reset:now var(--now);font-weight:700;grid-row:1;margin-bottom:var(--ld-sp-16);opacity:var(--ld-slider-highlighted);transform:translate(-50%) scale(max(.8,var(--ld-slider-highlighted)));transition:opacity var(--ld-slider-animation-duration) ease-out,transform var(--ld-slider-animation-duration) ease-out}:host .ld-slider__output:before{background:var(--ld-slider-selected-col);border-radius:var(--ld-br-m);content:\"\";inset:0;position:absolute;z-index:-1}:host .ld-slider__output:after{content:counter(now) var(--unit);counter-reset:now var(--now);display:block;padding:0 var(--ld-sp-6)}:host .ld-slider__output--permanent{color:var(--ld-slider-selected-col);opacity:1;transform:translate(-50%,calc((var(--ld-slider-highlighted) - 1)*var(--ld-sp-12)*-1));transition:transform var(--ld-slider-animation-duration) ease-out}:host .ld-slider__output--permanent:before{opacity:var(--ld-slider-highlighted);transition:opacity var(--ld-slider-animation-duration) ease-out}:host .ld-slider__output--permanent:after{filter:invert(var(--ld-slider-highlighted)) grayscale(var(--ld-slider-highlighted)) contrast(max(1,calc(var(--ld-slider-highlighted)*4)))}";

const findClosest = (items, currValue) => items.length
  ? items.reduce((prevItem, item) => Math.abs(item - currValue) < Math.abs(prevItem - currValue)
    ? item
    : prevItem)
  : currValue;
const findNext = (items, currValue) => findClosest(items.filter((item) => item > currValue), currValue);
const findPrev = (items, currValue) => findClosest(items.filter((item) => item < currValue), currValue);
let sliderCount = 0;
const LdSlider$1 = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ldchange = createEvent(this, "ldchange", 7);
    this.idPrefix = `ld-slider-${++sliderCount}`;
    /** Disabled state of the slider */
    this.disabled = false;
    /** Prevents rendering of the stop labels below the slider */
    this.hideStopLabels = false;
    /** Prevents rendering of the value labels below the slider */
    this.hideValueLabels = false;
    /** Makes the current values only visible on interaction */
    this.hideValues = false;
    /** Specifies the legal number intervals */
    this.indicators = false;
    /** "From" value label (when exactly 2 values are given) */
    this.labelFrom = 'From';
    /** "To" value label (when exactly 2 values are given) */
    this.labelTo = 'To';
    /** "Value" label (when exactly 2 values are given) */
    this.labelValue = 'Value';
    /** Specifies the maximum value allowed */
    this.max = 100;
    /** Specifies the minimum value allowed */
    this.min = 0;
    /** Swap which areas are being marked as selected and deselected */
    this.negative = false;
    /** Allows swapping of thumbs */
    this.swappable = false;
    /** Specifies the default value */
    this.value = String(this.min);
    /** Width of the slider */
    this.width = '100%';
    this.valueLabels = [];
    this.steps = [];
    this.values = [];
    this.handleTrackClick = (ev) => {
      if (ev.composedPath()[0] !== this.el) {
        return;
      }
      const afterStyles = getComputedStyle(this.el, 'after');
      const paddingLeft = Number.parseInt(getComputedStyle(this.el).paddingLeft) || 0;
      const marginLeft = Number.parseInt(afterStyles.marginLeft) || 0;
      const trackWidth = Number.parseInt(afterStyles.width);
      const clickPosition = ev.offsetX - paddingLeft - marginLeft;
      const newValue = Math.round((clickPosition / trackWidth) * (this.max - this.min)) +
        this.min;
      const values = [...this.values];
      const index = values.indexOf(findClosest(values, newValue));
      const correctedValue = this.getCorrectedValue(newValue, index, values);
      values.splice(index, 1, correctedValue);
      this.value = values.join(',');
    };
    this.handleInput = (ev, index) => {
      const target = ev.target;
      if (this.ariaDisabled === 'true') {
        target.value = String(this.values[index]);
        return;
      }
      const currValue = Number.parseInt(target.value, 10);
      const values = [...this.values];
      const correctedValue = this.getCorrectedValue(currValue, index, values, true);
      values[index] = correctedValue;
      if (correctedValue !== currValue) {
        target.value = String(correctedValue);
      }
      const newValue = values.join(',');
      if (this.value !== newValue) {
        this.value = values.join(',');
      }
    };
    this.handleKeyDown = (ev, index) => {
      const target = ev.target;
      if (this.ariaDisabled === 'true') {
        target.value = String(this.values[index]);
        return;
      }
      const prevValue = Number.parseInt(target.value, 10);
      const values = [...this.values];
      let currValue;
      if (this.stops && !this.snapOffset) {
        switch (ev.key) {
          case 'ArrowDown':
          case 'ArrowLeft':
            currValue = findPrev(this.steps, prevValue);
            break;
          case 'ArrowRight':
          case 'ArrowUp':
            currValue = findNext(this.steps, prevValue);
        }
      }
      else if (this.snapOffset) {
        switch (ev.key) {
          case 'ArrowDown':
          case 'ArrowLeft':
            currValue = prevValue - 1;
            break;
          case 'ArrowRight':
          case 'ArrowUp':
            currValue = prevValue + 1;
        }
      }
      if (currValue === undefined) {
        return;
      }
      ev.preventDefault();
      const correctedValue = this.getCorrectedValue(currValue, index, values);
      if (correctedValue === prevValue) {
        return;
      }
      values[index] = correctedValue;
      target.value = String(correctedValue);
      const newValue = values.join(',');
      if (this.value !== newValue) {
        this.value = values.join(',');
      }
    };
    this.getCorrectedValue = (currValue, index, values, snap = false) => {
      const prevValue = values[index - 1];
      const nextValue = values[index + 1];
      if (currValue < this.min) {
        return this.min;
      }
      if (currValue > this.max) {
        return this.max;
      }
      if (!this.swappable && prevValue > currValue) {
        return prevValue;
      }
      if (!this.swappable && nextValue < currValue) {
        return nextValue;
      }
      if (snap && this.snapOffset !== undefined) {
        const stepToSnapTo = this.steps.find((step) => currValue <= step + this.snapOffset &&
          currValue >= step - this.snapOffset);
        return stepToSnapTo !== null && stepToSnapTo !== void 0 ? stepToSnapTo : currValue;
      }
      if (this.steps.length && this.snapOffset === undefined) {
        return findClosest(this.steps, currValue);
      }
      return currValue;
    };
    this.validateValue = (currValue, index, values) => currValue === this.getCorrectedValue(currValue, index, values);
    this.correctValues = (values) => {
      const correctedValues = values.map(this.getCorrectedValue);
      if (!correctedValues.every(this.validateValue)) {
        return this.correctValues(correctedValues);
      }
      return correctedValues;
    };
    this.updateValues = (autoCorrectValues = false) => {
      const values = this.value
        .split(',')
        .map((value) => Number.parseInt(value, 10));
      if (!values.every(this.validateValue)) {
        if (autoCorrectValues) {
          this.value = this.correctValues(values).join(',');
        }
        return false;
      }
      this.values = values;
      return true;
    };
  }
  /** Focuses the toggle */
  async focusInner() {
    var _a;
    (_a = this.firstSliderRef) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
  }
  updateState() {
    this.steps = this.stops
      ? [
        this.min,
        ...this.stops
          .split(',')
          .map((valueLabel) => Number.parseInt(valueLabel, 10)),
        this.max,
      ]
      : this.step
        ? Array(Math.floor((this.max - this.min) / this.step) + 1)
          .fill(this.min)
          .map((min, index) => min + index * this.step)
        : [];
    this.valueLabels = this.stops ? [...this.steps] : [this.min, this.max];
  }
  handleValueChange() {
    const success = this.updateValues();
    if (success) {
      this.ldchange.emit(this.values);
    }
  }
  componentWillLoad() {
    this.updateState();
    this.updateValues(true);
  }
  render() {
    const cssValues = this.values.reduce((prev, curr, index) => {
      prev[`--value${index}`] = curr;
      return prev;
    }, {});
    return (h(Host, { class: getClassNames([
        'ld-slider',
        this.hideValueLabels && 'ld-slider--padded',
        this.size && `ld-slider--${this.size}`,
      ]), onClick: this.handleTrackClick, role: "group", style: Object.assign(Object.assign({}, cssValues), { '--ld-slider-width': this.width, '--min': String(this.min), '--max': String(this.max), '--fill': (this.negative
          ? `
linear-gradient(
  90deg,
  red 100%,
  transparent 0
),`
          : '') +
          this.values
            .map((_, index) => `
linear-gradient(
  90deg,
  red
    calc(
      var(--ld-slider-radius) - var(--ld-slider-track-margin) +
        (var(--value${index}) - var(--min)) / var(--ld-slider-diff) *
        (var(--ld-slider-useful-width)${this.width === '100%' ? ' + 2 * var(--ld-slider-track-margin)' : ''})
    ),
  transparent 0
)`)
            .join(',') }) }, this.values.map((value, index) => {
      var _a;
      return (h(Fragment, null, h("ld-sr-only", { id: `${this.idPrefix}-label-${index}`, key: `label-${index}`, part: "label" }, this.values.length === 2
        ? index === 0
          ? this.labelFrom
          : this.labelTo
        : `${this.labelValue} ${index + 1}`), h("input", { "aria-disabled": this.disabled || this.ariaDisabled === 'true'
          ? 'true'
          : undefined, "aria-labelledby": `${this.idPrefix}-label-${index}`, "aria-valuetext": this.unit ? value + this.unit : undefined, class: "ld-slider__input", disabled: this.disabled, id: `${this.idPrefix}-value-${index}`, key: `input-${index}`, max: this.max, min: this.min, onInput: (ev) => this.handleInput(ev, index), onKeyDown: (ev) => this.handleKeyDown(ev, index), part: "input focusable", ref: index === 0
          ? (ref) => {
            this.firstSliderRef = ref;
          }
          : undefined, step: this.snapOffset !== undefined ? undefined : this.step, style: 
        // prevents that thumb is not movable, when swappable prop is not set
        value === this.max && this.values[index - 1] === this.max
          ? {
            zIndex: '2',
          }
          : undefined, tabindex: this.ldTabindex, type: "range", value: value }), h("output", { class: getClassNames([
          'ld-slider__output',
          !this.hideValues && 'ld-slider__output--permanent',
        ]), htmlFor: `${this.idPrefix}-value-${index}`, key: `output-${index}`, part: "output", style: {
          '--now': `var(--value${index})`,
          '--unit': `"${(_a = this.unit) !== null && _a !== void 0 ? _a : ''}"`,
        } })));
    }), this.indicators &&
      this.steps.map((step) => (h("div", { class: "ld-slider__indicator", key: `indicator-${step}`, part: "indicator", style: { '--now': String(step) } }))), !this.hideValueLabels &&
      this.valueLabels.map((valueLabel, index) => (index === 0 ||
        index === this.valueLabels.length - 1 ||
        !this.hideStopLabels) && (h("div", { class: getClassNames([
          'ld-slider__value-label',
          index === 0 && 'ld-slider__value-label--first',
          index === this.valueLabels.length - 1 &&
            'ld-slider__value-label--last',
        ]), key: `value-label-${valueLabel}`, part: "value-label", style: { '--now': String(valueLabel) } }, valueLabel, this.unit)))));
  }
  get el() { return this; }
  static get watchers() { return {
    "max": ["updateState"],
    "min": ["updateState"],
    "step": ["updateState"],
    "stops": ["updateState"],
    "value": ["handleValueChange"]
  }; }
  static get style() { return ldSliderShadowCss; }
}, [1, "ld-slider", {
    "ariaDisabled": [1, "aria-disabled"],
    "disabled": [4],
    "hideStopLabels": [4, "hide-stop-labels"],
    "hideValueLabels": [4, "hide-value-labels"],
    "hideValues": [4, "hide-values"],
    "indicators": [4],
    "labelFrom": [1, "label-from"],
    "labelTo": [1, "label-to"],
    "labelValue": [1, "label-value"],
    "max": [2],
    "min": [2],
    "negative": [4],
    "size": [1],
    "snapOffset": [2, "snap-offset"],
    "step": [2],
    "stops": [1],
    "swappable": [4],
    "ldTabindex": [2, "ld-tabindex"],
    "unit": [1],
    "value": [1537],
    "width": [1],
    "valueLabels": [32],
    "steps": [32],
    "values": [32],
    "focusInner": [64]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-slider", "ld-sr-only"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-slider":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSlider$1);
      }
      break;
    case "ld-sr-only":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdSlider = LdSlider$1;
const defineCustomElement = defineCustomElement$1;

export { LdSlider, defineCustomElement };
