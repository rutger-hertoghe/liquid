import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { T as Tether } from './tether.esm.js';
import { g as getClassNames } from './getClassNames.js';
import { d as defineCustomElement$2 } from './ld-sr-only2.js';
import { d as defineCustomElement$1 } from './ld-tooltip-popper2.js';

const ldTooltipShadowCss = ".ld-tooltip__trigger{--ld-tooltip-trigger-icon-col:var(--ld-thm-primary);--ld-tooltip-trigger-icon-col-hover:var(--ld-thm-primary-hover);--ld-tooltip-trigger-icon-col-focus:var(--ld-thm-primary-focus);background:none;border:0;color:inherit;display:inline-block;font-family:inherit;font-size:inherit;padding:0}.ld-tooltip__trigger--clickable{cursor:pointer}.ld-tooltip__trigger:focus:focus-visible .ld-tooltip__icon{color:var(--ld-tooltip-trigger-icon-col-focus)}.ld-tooltip__trigger:hover .ld-tooltip__icon{color:var(--ld-tooltip-trigger-icon-col-hover)}.ld-tooltip__trigger+.ld-tooltip{display:none;opacity:0;position:absolute}.ld-tooltip__icon{color:var(--ld-tooltip-trigger-icon-col);display:flex;height:var(--ld-sp-16);width:var(--ld-sp-16)}";

let tooltipCount = 0;
const LdTooltip = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.idDescriber = `ld-tooltip-${++tooltipCount}`;
    /** Delay in ms until tooltip hides (only when trigger type is 'hover') */
    this.hideDelay = 0;
    /** Position of the tooltip relative to the trigger element (also affects the arrow position) */
    this.position = 'top center';
    /** Delay in ms until tooltip shows (only when trigger type is 'hover') */
    this.showDelay = 0;
    /** The rendered HTML tag for the tooltip trigger. */
    this.tag = 'button';
    /** Event type that triggers the tooltip */
    this.triggerType = 'hover';
    this.hasDefaultTrigger = true;
    this.visible = false;
    this.mapPositionToAttachment = (position) => {
      return {
        'bottom center': 'top center',
        'bottom left': 'top left',
        'bottom right': 'top right',
        'left bottom': 'bottom right',
        'left middle': 'middle right',
        'left top': 'top right',
        'right bottom': 'bottom left',
        'right middle': 'middle left',
        'right top': 'top left',
        'top center': 'bottom center',
        'top left': 'bottom left',
        'top right': 'bottom right',
      }[position];
    };
    this.mapPositionToTargetAttachment = (position) => {
      var _a;
      return ((_a = {
        'left bottom': 'bottom left',
        'left middle': 'middle left',
        'left top': 'top left',
        'right bottom': 'bottom right',
        'right middle': 'middle right',
        'right top': 'top right',
      }[position]) !== null && _a !== void 0 ? _a : position);
    };
    this.initTooltip = async () => {
      const attachment = this.mapPositionToAttachment(this.position);
      const targetAttachment = this.mapPositionToTargetAttachment(this.position);
      const tooltipContent = this.tooltipRef.querySelector('slot').assignedNodes();
      tooltipContent.forEach((node) => {
        this.tooltipRef.appendChild(node);
      });
      const customTetherOptions = typeof this.tetherOptions === 'string'
        ? JSON.parse(this.tetherOptions)
        : this.tetherOptions;
      const tetherOptions = Object.assign({ attachment, classPrefix: 'ld-tether', constraints: [
          {
            attachment: 'together',
            to: 'window',
          },
        ], element: this.tooltipRef, target: this.triggerRef, targetAttachment }, customTetherOptions);
      this.popper = new Tether(tetherOptions);
      // Fixes a tether positioning bug
      this.popper.enable();
      this.popper.enable();
      this.popper.enable();
      this.popper.enable();
      this.visible = true;
    };
    this.toggleTooltip = () => {
      if (this.popper == undefined) {
        return;
      }
      if (this.visible) {
        this.hideTooltip();
      }
      else {
        this.showTooltip();
      }
    };
    this.handleHideTrigger = () => {
      if (this.triggerType === 'click' || this.disabled) {
        return;
      }
      clearTimeout(this.delayTimeout);
      if (this.popper) {
        this.delayTimeout = setTimeout(() => {
          this.hideTooltip();
        }, this.hideDelay);
      }
    };
    this.handleShowTrigger = () => {
      if (this.triggerType === 'click' || this.disabled) {
        return;
      }
      clearTimeout(this.delayTimeout);
      if (this.popper === undefined) {
        this.delayTimeout = setTimeout(this.initTooltip, this.showDelay);
      }
      else {
        this.delayTimeout = setTimeout(this.showTooltip.bind(this), this.showDelay);
      }
    };
    this.handleToggleTrigger = () => {
      if (this.triggerType === 'hover' || this.disabled) {
        return;
      }
      if (this.popper === undefined) {
        this.initTooltip();
      }
      else {
        this.toggleTooltip();
      }
    };
  }
  updatePopper(newDisabled) {
    if (newDisabled) {
      this.hideTooltip();
    }
  }
  /** Hide tooltip */
  async hideTooltip() {
    var _a;
    clearTimeout(this.delayTimeout);
    (_a = this.popper) === null || _a === void 0 ? void 0 : _a.disable();
    this.visible = false;
  }
  /** Show tooltip */
  async showTooltip() {
    if (this.disabled)
      return;
    clearTimeout(this.delayTimeout);
    this.popper.enable();
    this.visible = true;
  }
  // TODO: maybe this should listen only, if the tooltip was opened by click.
  handleClickOutside(event) {
    if (this.popper &&
      this.triggerType === 'click' &&
      event.target.closest('ld-tooltip') !== this.element &&
      event.target.closest('.ld-tooltip') !== this.tooltipRef) {
      this.hideTooltip();
    }
  }
  // Mobile Safari in some cases does not react to click events on elements
  // which are not interactive. But it does to touch events.
  // TODO: maybe this should listen only, if the tooltip was opened by click.
  handleTouchOutside(event) {
    this.handleClickOutside(event);
  }
  componentWillLoad() {
    this.hasDefaultTrigger = !this.element.querySelector('[slot="trigger"]');
  }
  disconnectedCallback() {
    var _a, _b;
    (_a = this.popper) === null || _a === void 0 ? void 0 : _a.destroy();
    (_b = this.tooltipRef) === null || _b === void 0 ? void 0 : _b.remove();
  }
  render() {
    const TriggerTag = this.tag;
    return (h(Host, null, h(TriggerTag, { "aria-describedby": this.idDescriber, class: getClassNames([
        'ld-tooltip__trigger',
        this.triggerType === 'click' && 'ld-tooltip__trigger--clickable',
      ]), onClick: this.handleToggleTrigger, onMouseEnter: this.handleShowTrigger, onFocus: this.handleShowTrigger, onMouseLeave: this.handleHideTrigger, onBlur: this.handleHideTrigger, part: "trigger focusable", ref: (element) => {
        this.triggerRef = element;
      }, type: "button" }, h("ld-sr-only", null, "Info"), h("slot", { name: "trigger" }, h("svg", { class: "ld-tooltip__icon", fill: "none", part: "icon", viewBox: "0 0 24 24" }, h("path", { "clip-rule": "evenodd", d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.9249 18.0751 1 12 1C5.9249 1 1 5.9249 1 12C1 18.0751 5.9249 23 12 23Z", "fill-rule": "evenodd", fill: "currentColor" }), h("path", { "clip-rule": "evenodd", d: "M11.9996 8.6477C12.9254 8.6477 13.6758 7.8973 13.6758 6.9715C13.6758 6.0458 12.9254 5.2953 11.9996 5.2953C11.0739 5.2953 10.3235 6.0458 10.3235 6.9715C10.3235 7.8973 11.0739 8.6477 11.9996 8.6477ZM10.8453 17.8038C11.1932 18.1517 11.6736 18.3256 12.2865 18.3256H13.4545C13.6864 18.3256 13.8023 18.2263 13.8023 18.0275V12.2873C13.8023 11.6744 13.6284 11.1939 13.2805 10.8461C12.9326 10.4982 12.4522 10.3242 11.8393 10.3242H10.6713C10.4394 10.3242 10.3235 10.4236 10.3235 10.6224V16.3626C10.3235 16.9755 10.4974 17.456 10.8453 17.8038Z", "fill-rule": "evenodd",
      // TODO: replace color with icon-specific custom property and use ld-icon
      fill: "var(--ld-col-wht)" })))), h("ld-tooltip-popper", { "aria-hidden": this.visible ? undefined : 'true', arrow: this.arrow, hasDefaultTrigger: this.hasDefaultTrigger, id: this.idDescriber, part: "popper", size: this.size, ref: (element) => {
        this.tooltipRef = element;
      }, triggerType: this.triggerType }, h("slot", null))));
  }
  get element() { return this; }
  static get watchers() { return {
    "disabled": ["updatePopper"]
  }; }
  static get style() { return ldTooltipShadowCss; }
}, [1, "ld-tooltip", {
    "arrow": [4],
    "disabled": [4],
    "hideDelay": [2, "hide-delay"],
    "position": [1],
    "showDelay": [2, "show-delay"],
    "size": [1],
    "tag": [1],
    "tetherOptions": [1, "tether-options"],
    "triggerType": [1, "trigger-type"],
    "hasDefaultTrigger": [32],
    "visible": [32],
    "hideTooltip": [64],
    "showTooltip": [64]
  }, [[8, "click", "handleClickOutside"], [9, "touchend", "handleTouchOutside"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-tooltip", "ld-sr-only", "ld-tooltip-popper"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-tooltip":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdTooltip);
      }
      break;
    case "ld-sr-only":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
    case "ld-tooltip-popper":
      if (!customElements.get(tagName)) {
        defineCustomElement$1();
      }
      break;
  } });
}
defineCustomElement();

export { LdTooltip as L, defineCustomElement as d };
