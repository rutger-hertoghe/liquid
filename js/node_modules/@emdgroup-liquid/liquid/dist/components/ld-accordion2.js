import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';

/**
 * Returns the scroll parent (the first scrollable ancestor of a given element).
 * This is a vanilla JS port of the jQuery UI scrollParent method:
 * https://github.com/jquery/jquery-ui/blob/main/ui/scroll-parent.js
 */
function getScrollParent(element, includeHidden) {
  let style = getComputedStyle(element);
  if (style.position === 'fixed') {
    return document.scrollingElement;
  }
  const excludeStaticParent = style.position === 'absolute';
  const overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/;
  // Using for loop instead of recursion in order to save memory.
  for (let parent = element; (parent = parent.parentElement);) {
    style = getComputedStyle(parent);
    if (excludeStaticParent && style.position === 'static') {
      continue;
    }
    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) {
      return parent;
    }
  }
  return document.scrollingElement;
}

const ldAccordionShadowCss = ":host{--ld-accordion-col:var(--ld-col-neutral-900);--ld-accordion-col-disabled:var(--ld-col-neutral-100);--ld-accordion-col-hover:var(--ld-col-neutral-900);--ld-accordion-col-focus:var(--ld-col-neutral-900);--ld-accordion-bg-col:var(--ld-col-wht);--ld-accordion-bg-col-active:var(--ld-col-wht);--ld-accordion-bg-col-disabled:var(--ld-col-neutral-100);--ld-accordion-bg-col-focus:var(--ld-col-neutral-100);--ld-accordion-bg-col-hover:var(--ld-col-neutral-050);--ld-accordion-trigger-icon-col-disabled:var(--ld-col-neutral-100);--ld-accordion-col-active:var(--ld-thm-primary);--ld-accordion-col-selected:var(--ld-thm-primary);--ld-accordion-toggle-col:inherit;--ld-accordion-toggle-indicator-bg-col:#0000;--ld-accordion-toggle-trigger-col:var(--ld-thm-primary);--ld-accordion-trigger-icon-col:var(--ld-thm-primary);--ld-accordion-trigger-icon-col-hover:var(--ld-thm-primary-hover);--ld-accordion-trigger-icon-col-focus:var(--ld-thm-primary-focus);--ld-accordion-trigger-icon-col-active:var(--ld-thm-primary-active);--ld-accordion-toggle-expanded-col:var(--ld-thm-primary);--ld-accordion-padding-y:0.45rem;--ld-accordion-padding-x:1.25rem;--ld-accordion-toggle-size:2.5rem;--ld-accordion-toggle-line-height:180%;--ld-accordion-border-radius-size:0;--ld-accordion-border-radius:var(--ld-accordion-border-radius-size);--ld-accordion-gap:var(--ld-sp-2);--ld-accordion-gap-col:var(--ld-accordion-panel-border-top-col);--ld-accordion-panel-border-top-col:var(--ld-col-neutral-010)}:host(:where(.ld-accordion)){display:block;flex-grow:1}:host(.ld-accordion--rounded){--ld-accordion-border-radius-size:var(--ld-br-m)}:host(.ld-accordion--dark){--ld-accordion-bg-col:var(--ld-col-neutral-010);--ld-accordion-bg-col-active:var(--ld-col-neutral-010);--ld-accordion-panel-border-top-col:var(--ld-col-neutral-050)}:host(.ld-accordion--brand-color){--ld-accordion-bg-col-hover:var(--ld-thm-primary-alpha-lowest);--ld-accordion-bg-col-focus:var(--ld-thm-primary-alpha-low)}:host(.ld-accordion--detached){--ld-accordion-gap:var(--ld-sp-8);--ld-accordion-gap-col:#0000}:host(.ld-accordion:not(.ld-accordion--detached)) ::slotted(ld-accordion-section){--ld-accordion-border-radius:0}:host(.ld-accordion:not(.ld-accordion--detached)) ::slotted(ld-accordion-section:first-of-type){--ld-accordion-border-radius:var(--ld-accordion-border-radius-size) var(--ld-accordion-border-radius-size) 0 0}:host(.ld-accordion:not(.ld-accordion--detached)) ::slotted(ld-accordion-section:last-of-type){--ld-accordion-border-radius:0 0 var(--ld-accordion-border-radius-size) var(--ld-accordion-border-radius-size)}:host ::slotted(ld-accordion-section:not(:first-of-type)){border-top:solid var(--ld-accordion-gap) var(--ld-accordion-gap-col)}";

const LdAccordion = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.scrollIntoViewOnTransitionEnd = false;
    /** Sets a small gap between each accordion section. */
    this.detached = false;
    /** Applies rounded corners. */
    this.rounded = false;
    /** When set to true, an open accordion element closes, if anthorer one opens. */
    this.single = false;
    this.scrollIntoView = (section) => {
      var _a;
      const scrollParent = getScrollParent(section);
      const toggle = section.querySelector('ld-accordion-toggle');
      const panel = section.querySelector('ld-accordion-panel');
      // singleModeDelta is the height of the currently open panel, that needs
      // to be subtracted from the scroll amount in single mode.
      const allSections = Array.from(section.parentElement.children);
      const singleModeDelta = this.single && !this.scrollIntoViewOnTransitionEnd
        ? ((_a = allSections
          .slice(0, allSections.findIndex((sec) => sec === section))
          .find((sec) => sec.classList.contains('ld-accordion-section--expanded'))) === null || _a === void 0 ? void 0 : _a.children[1].scrollHeight) || 0
        : 0;
      const panelOffsetToScrollParent = scrollParent.scrollTop +
        panel.getBoundingClientRect().top -
        Math.max(0, scrollParent.getBoundingClientRect().top);
      const scrollPaddingTop = parseFloat(window.getComputedStyle(scrollParent)['scrollPaddingTop']) || 0;
      // targetOffsetBottom is the distance from the scrollParent top to the
      // bottom of the section that is being expanded in its expanded state.
      const targetOffsetBottom = panelOffsetToScrollParent +
        Math.min(panel.scrollHeight, scrollParent.clientHeight - toggle.clientHeight - scrollPaddingTop) -
        singleModeDelta;
      // If an accordion section expands at the bottom end of the accordion
      // The scroll container may not have a sufficient height at that time
      // in order to be scrollable to the target offset. In this case we
      // postpone the scrolling to the transition end event.
      if (!this.scrollIntoViewOnTransitionEnd &&
        scrollParent.scrollHeight < targetOffsetBottom) {
        this.scrollIntoViewOnTransitionEnd = true;
        return;
      }
      if (!this.el.closest('ld-accordion-panel') &&
        scrollParent.clientHeight + scrollParent.scrollTop < targetOffsetBottom) {
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        scrollParent.scrollTo({
          top: targetOffsetBottom - scrollParent.clientHeight,
          behavior: prefersReducedMotion ? 'auto' : 'smooth',
        });
      }
    };
    this.focusToggle = (currentToggle, dir) => {
      var _a;
      const toggleToFocus = (_a = (dir === 'prev'
        ? currentToggle.parentElement.previousElementSibling
        : currentToggle.parentElement.nextElementSibling)) === null || _a === void 0 ? void 0 : _a.querySelector('ld-accordion-toggle');
      if (toggleToFocus) {
        toggleToFocus.focusInner();
      }
    };
    this.onKeydown = (ev) => {
      if (ev.target.tagName !== 'LD-ACCORDION-TOGGLE') {
        return;
      }
      switch (ev.key) {
        case 'ArrowUp': {
          ev.preventDefault();
          this.focusToggle(ev.target, 'prev');
          return;
        }
        case 'ArrowDown': {
          ev.preventDefault();
          this.focusToggle(ev.target, 'next');
          return;
        }
      }
    };
    this.onTransitionEnd = (ev) => {
      const target = ev.target;
      if (!this.scrollIntoViewOnTransitionEnd ||
        target.tagName !== 'LD-ACCORDION-PANEL' ||
        target.closest('ld-accordion') !== this.el ||
        !target.closest('ld-accordion-section').expanded) {
        return;
      }
      this.scrollIntoView(target.closest('ld-accordion-section'));
      this.scrollIntoViewOnTransitionEnd = false;
    };
  }
  handleAccordionExpandChange(ev) {
    if (ev.target.tagName !== 'LD-ACCORDION-SECTION')
      return;
    // In single mode, close sibling sections of open section.
    if (this.single && ev.target.expanded) {
      const siblings = [...ev.target.parentElement.children].filter((section) => section !== ev.target);
      siblings.forEach((section) => {
        section.expanded = false;
      });
    }
    if (ev.detail /* expanded */) {
      this.scrollIntoView(ev.target);
    }
  }
  render() {
    const cl = getClassNames([
      'ld-accordion',
      this.detached && 'ld-accordion--detached',
      this.brandColor && 'ld-accordion--brand-color',
      !this.brandColor && this.tone && `ld-accordion--${this.tone}`,
      this.rounded && 'ld-accordion--rounded',
    ]);
    return (h(Host, { class: cl, onKeydown: this.onKeydown, onTransitionEnd: this.onTransitionEnd }, h("slot", null)));
  }
  get el() { return this; }
  static get style() { return ldAccordionShadowCss; }
}, [1, "ld-accordion", {
    "brandColor": [4, "brand-color"],
    "detached": [4],
    "rounded": [4],
    "single": [4],
    "tone": [1]
  }, [[1, "ldaccordionchange", "handleAccordionExpandChange"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-accordion"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-accordion":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdAccordion);
      }
      break;
  } });
}
defineCustomElement();

export { LdAccordion as L, defineCustomElement as d };
