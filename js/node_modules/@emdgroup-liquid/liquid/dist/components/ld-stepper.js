import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { d as defineCustomElement$2 } from './ld-sr-only2.js';

const ldStepperCss = ".ld-stepper,:host{--ld-stepper-gap:var(--ld-stepper-gap-md);--ld-stepper-gap-sm:var(--ld-sp-16);--ld-stepper-gap-md:1.25rem;--ld-stepper-gap-lg:var(--ld-sp-24);display:block}.ld-stepper ol,:host ol{display:grid;gap:var(--ld-stepper-gap);grid-auto-columns:minmax(0,1fr);grid-auto-flow:column;height:100%;padding:0}.ld-stepper--vertical ol,:host(.ld-stepper--vertical) ol{flex-direction:column;grid-auto-flow:row;grid-auto-rows:1fr}.ld-stepper--fit-content ol,:host(.ld-stepper--fit-content) ol{display:flex}.ld-stepper--sm,:host(.ld-stepper--sm){--ld-stepper-gap:var(--ld-stepper-gap-sm)}.ld-stepper--lg,:host(.ld-stepper--lg){--ld-stepper-gap:var(--ld-stepper-gap-lg)}";

const LdStepper$1 = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    /** Switch colors for brand background. */
    this.brandColor = false;
    /** Indicates whether the steps should be evenly distributed or fit to their content */
    this.fitContent = false;
    /** Template for the screen-reader label, containing the label of the current step and the steps summary */
    this.labelTemplate = '$1, $2';
    /** Step summary template for the screen-reader label, containing the index of the current step and the overall number of steps */
    this.labelSummaryTemplate = 'step $1 of $2';
    /** Vertical layout */
    this.vertical = false;
    this.updateCurrent = (event) => {
      this.currentIndex = event.detail.index;
      this.currentLabel = event.detail.label;
    };
  }
  getLabel() {
    const summary = this.labelSummaryTemplate
      .replace('$1', String(this.currentIndex + 1))
      .replace('$2', String(this.steps.length));
    return this.currentLabel
      ? this.labelTemplate
        .replace('$1', this.currentLabel)
        .replace('$2', summary)
      : summary;
  }
  propagateProps() {
    this.steps.forEach((ldStep) => {
      ldStep.brandColor = this.brandColor;
      ldStep.size = this.size;
      ldStep.vertical = this.vertical;
    });
  }
  componentWillLoad() {
    this.steps = this.el.querySelectorAll('ld-step');
    this.propagateProps();
  }
  render() {
    return (h(Host, { class: getClassNames([
        'ld-stepper',
        this.fitContent && 'ld-stepper--fit-content',
        this.size && `ld-stepper--${this.size}`,
        this.vertical && 'ld-stepper--vertical',
      ]), role: "navigation", onLdstepselected: this.updateCurrent }, h("ld-sr-only", null, this.getLabel()), h("ol", { part: "list" }, h("slot", null))));
  }
  get el() { return this; }
  static get watchers() { return {
    "brandColor": ["propagateProps"],
    "size": ["propagateProps"],
    "vertical": ["propagateProps"]
  }; }
  static get style() { return ldStepperCss; }
}, [1, "ld-stepper", {
    "brandColor": [4, "brand-color"],
    "fitContent": [4, "fit-content"],
    "labelTemplate": [1, "label-template"],
    "labelSummaryTemplate": [1, "label-summary-template"],
    "size": [8],
    "vertical": [4],
    "currentLabel": [32],
    "currentIndex": [32],
    "steps": [32]
  }]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-stepper", "ld-sr-only"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-stepper":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdStepper$1);
      }
      break;
    case "ld-sr-only":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdStepper = LdStepper$1;
const defineCustomElement = defineCustomElement$1;

export { LdStepper, defineCustomElement };
