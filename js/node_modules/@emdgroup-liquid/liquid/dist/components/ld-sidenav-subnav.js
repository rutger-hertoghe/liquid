import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { c as closest } from './closest.js';
import { d as defineCustomElement$3 } from './ld-sidenav-scroller-internal2.js';
import { d as defineCustomElement$2 } from './ld-sidenav-separator2.js';

const ldSidenavSubnavShadowCss = ":host{--ld-sidenav-accordion-bg-col-hover:var(--ld-col-neutral-100);background:var(\n    --ld-sidenav-bg-color\n  );display:none;height:100%;position:absolute;top:0;transform:translateX(100%);visibility:hidden;width:100%;z-index:1}:host(.ld-sidenav-subnav--active){display:block}:host ::slotted(:where(:not(ld-sidenav-separator):not(ld-sidenav-navitem):not(ld-sidenav-subnav))){margin-bottom:var(--ld-sidenav-padding-y);transition:var(--ld-sidenav-collapse-content-transition);will-change:opacity,transform}:host ::slotted(.ld-sidenav-subnav__hidden){opacity:0;transform:translateX(var(--ld-sidenav-translate-x-delta));transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;visibility:hidden}:host ::slotted(.ld-sidenav-accordion){transform:none}.ld-sidenav-subnav__background{background-color:var(--ld-sidenav-bg-color);inset:0;opacity:0;position:absolute;transition:opacity var(--ld-sidenav-transition-duration) linear}.ld-sidenav-subnav__background:before{background-color:var(--ld-sidenav-subnav-bg-color);content:\"\";inset:0;position:absolute}.ld-sidenav-subnav__background--active{opacity:1}:host(.ld-sidenav-subnav--has-parent-subnav) .ld-sidenav-subnav__background{opacity:1}";

const LdSidenavSubnav$1 = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    /**
     * @internal
     * Internal prop indicating that the subnav is about to become active which
     * may happen before a transition finishes after which it actually becomes active.
     */
    this.activeBeforeTransition = false;
    /**
     * @internal
     * Internal prop indicating that the subnav is either ancestor of the
     * currently visible subnav or the currently visible subnav itself.
     */
    this.active = false;
    /**
     * @internal
     * Internal prop indicating that the subnav is ancestor of the
     * currently visible subnav.
     */
    this.ancestor = false;
    this.toggleVisibilityOnHidableContent = (visible) => {
      Array.from(this.el.children).forEach((el) => {
        // To also hide one of the following elements,
        // it is possible to wrap it in a div with display contents.
        if (![
          'LD-SIDENAV-ACCORDION',
          'LD-SIDENAV-NAVITEM',
          'LD-SIDENAV-SEPARATOR',
          'LD-SIDENAV-SUBNAV',
        ].includes(el.tagName)) {
          el.classList.toggle('ld-sidenav-subnav__hidden', !visible);
        }
      });
    };
  }
  /** Scrolls the subnav scroll container to the top. */
  async scrollToTop(smoothly = false) {
    this.scrollerRef.scrollToTop(smoothly);
  }
  onActiveChange(active) {
    var _a;
    if (active) {
      (_a = this.scrollerRef) === null || _a === void 0 ? void 0 : _a.updateShadows();
    }
  }
  onActiveBeforeTransitionChange(activeBeforeTransition) {
    this.updateBackground(activeBeforeTransition);
  }
  updateBackground(activeBeforeTransition) {
    // HACK: Timeout is required to make the transition work on nav item click
    setTimeout(() => {
      this.bgRef.classList.toggle('ld-sidenav-subnav__background--active', activeBeforeTransition);
    }, 20);
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    if (ev.detail.collapsed) {
      this.scrollToTop(true);
      this.toggleVisibilityOnHidableContent(false);
    }
    else {
      this.toggleVisibilityOnHidableContent(true);
    }
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    const sidenavClosable = ev.detail;
    if (sidenavClosable) {
      this.toggleVisibilityOnHidableContent(true);
    }
    else {
      this.toggleVisibilityOnHidableContent(!this.sidenav.collapsed);
    }
  }
  componentWillLoad() {
    this.sidenav = closest('ld-sidenav', this.el);
    this.hasParentSubnav = this.el.parentElement.tagName === 'LD-SIDENAV-SUBNAV';
  }
  render() {
    const cl = getClassNames([
      'ld-sidenav-subnav',
      this.active && 'ld-sidenav-subnav--active',
      this.hasParentSubnav && 'ld-sidenav-subnav--has-parent-subnav',
    ]);
    return (h(Host, { class: cl }, h("div", { ref: (el) => (this.bgRef = el), class: "ld-sidenav-subnav__background" }), h("ld-sidenav-scroller-internal", { style: {
        visibility: !this.active || this.ancestor ? 'hidden' : 'visible',
      }, part: "scroll-container", ref: (el) => (this.scrollerRef = el) }, h("slot", null))));
  }
  get el() { return this; }
  static get watchers() { return {
    "active": ["onActiveChange"],
    "activeBeforeTransition": ["onActiveBeforeTransitionChange"]
  }; }
  static get style() { return ldSidenavSubnavShadowCss; }
}, [1, "ld-sidenav-subnav", {
    "activeBeforeTransition": [4, "active-before-transition"],
    "active": [4],
    "ancestor": [4],
    "label": [1],
    "hasParentSubnav": [32],
    "scrollToTop": [64]
  }, [[9, "ldSidenavCollapsedChange", "handleSidenavCollapsedChange"], [9, "ldSidenavBreakpointChange", "handleSidenavBreakpointChange"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-sidenav-subnav", "ld-sidenav-scroller-internal", "ld-sidenav-separator"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-sidenav-subnav":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSidenavSubnav$1);
      }
      break;
    case "ld-sidenav-scroller-internal":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "ld-sidenav-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdSidenavSubnav = LdSidenavSubnav$1;
const defineCustomElement = defineCustomElement$1;

export { LdSidenavSubnav, defineCustomElement };
