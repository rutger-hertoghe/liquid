import { proxyCustomElement, HTMLElement, h, Host } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { c as closest } from './closest.js';
import { t as toggleStackToTop } from './toggleStackToTop.js';

const ldSidenavSeparatorShadowCss = ":host{display:block;margin:0 var(--ld-sidenav-padding-x) var(--ld-sidenav-padding-y);transform-origin:left;transition:transform var(--ld-sidenav-transition-duration-collapse-expand) ease}:host hr{background-color:var(--ld-sidenav-separator-line-bg-col);border:0;border-radius:var(--ld-br-full);height:var(--ld-sp-2);margin:0;transition:transform var(--ld-sidenav-transition-duration-collapse-expand) ease}:host(.ld-sidenav-separator--collapsed){transform:translateX(var(--ld-sidenav-translate-x-delta)) scaleX(var(--ld-sidenav-separator-scale-x-collapsed))}:host(.ld-sidenav-separator--collapsed) hr{transform:translateY(var(\n          --ld-slider-navitem-move-up-closable,var(--ld-slider-navitem-move-up,0)\n        ));transition:var(--ld-sidenav-stack-to-top-transition)}";

const LdSidenavSeparator = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.scaleXCollapsed = 1;
    this.computeScaleXCollapsed = () => {
      const sidenavWidth = parseFloat(window
        .getComputedStyle(this.sidenav)
        .getPropertyValue('--ld-sidenav-width'));
      const sidenavPaddingX = parseFloat(window
        .getComputedStyle(this.sidenav)
        .getPropertyValue('--ld-sidenav-padding-x'));
      const sidenavNavitemIconSize = parseFloat(window
        .getComputedStyle(this.sidenav)
        .getPropertyValue('--ld-sidenav-navitem-icon-size'));
      return sidenavNavitemIconSize / (sidenavWidth - 2 * sidenavPaddingX);
    };
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    this.sidenavCollapsed = ev.detail.collapsed;
    if (this.el.parentElement &&
      !['LD-SIDENAV-SLIDER', 'LD-SIDENAV-SUBNAV'].includes(this.el.parentElement.tagName)) {
      return;
    }
    if (this.sidenav.narrow) {
      toggleStackToTop(this.el, this.sidenavCollapsed);
    }
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    this.sidenavClosable = ev.detail;
    if (this.sidenavClosable) {
      toggleStackToTop(this.el, false);
    }
    else {
      toggleStackToTop(this.el, this.sidenav.narrow && this.sidenavCollapsed);
    }
  }
  componentWillLoad() {
    this.sidenav = closest('ld-sidenav', this.el);
    if (this.sidenav) {
      this.scaleXCollapsed = this.computeScaleXCollapsed() || 1;
    }
  }
  render() {
    const cl = getClassNames([
      'ld-sidenav-separator',
      this.sidenavCollapsed &&
        !this.sidenavClosable &&
        'ld-sidenav-separator--collapsed',
    ]);
    return (h(Host, { style: {
        '--ld-sidenav-separator-scale-x-collapsed': this.scaleXCollapsed.toString(),
      }, class: cl }, h("hr", { part: "hr" })));
  }
  get el() { return this; }
  static get style() { return ldSidenavSeparatorShadowCss; }
}, [1, "ld-sidenav-separator", {
    "sidenavCollapsed": [32],
    "sidenavClosable": [32],
    "scaleXCollapsed": [32]
  }, [[9, "ldSidenavCollapsedChange", "handleSidenavCollapsedChange"], [9, "ldSidenavBreakpointChange", "handleSidenavBreakpointChange"]]]);
function defineCustomElement() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-sidenav-separator"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-sidenav-separator":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSidenavSeparator);
      }
      break;
  } });
}
defineCustomElement();

export { LdSidenavSeparator as L, defineCustomElement as d };
