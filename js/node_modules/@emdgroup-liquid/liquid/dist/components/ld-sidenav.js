import { proxyCustomElement, HTMLElement, createEvent, h, Host } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { g as getFirstFocusable } from './focus.js';
import { d as defineCustomElement$3 } from './ld-sidenav-scroller-internal2.js';
import { d as defineCustomElement$2 } from './ld-sidenav-separator2.js';

const ldSidenavShadowCss = ":host{--ld-sidenav-line-height:1.15;--ld-sidenav-padding-x:1rem;--ld-sidenav-padding-y:1rem;--ld-sidenav-padding:var(--ld-sidenav-padding-y) var(--ld-sidenav-padding-x);--ld-sidenav-toggle-size:var(--ld-sp-24);--ld-sidenav-toggle-top:calc(var(--ld-sidenav-padding-y)*2 + var(--ld-sidenav-navitem-icon-size) - var(--ld-sidenav-toggle-size)*0.5);--ld-sidenav-translate-x-delta:calc(var(--ld-sidenav-width) - var(--ld-sidenav-width-collapsed));--ld-sidenav-width:15.625rem;--ld-sidenav-width-collapsed:calc(var(--ld-sidenav-padding-x)*2 + var(--ld-sidenav-navitem-icon-size));--ld-sidenav-width-fully-collapsed:calc(var(--ld-sp-1)*-1);--ld-sidenav-navitem-active-indicator-border-width:0.1875rem;--ld-sidenav-navitem-icon-size:var(--ld-sp-32);--ld-sidenav-navitem-bg-inset:var(--ld-sp-6);--ld-sidenav-navitem-border-radius:var(--ld-br-l);--ld-sidenav-navitem-tertiary-indent:calc(var(--ld-sidenav-padding-x)*3 + 0.3125rem);--ld-sidenav-navitem-tertiary-width:calc(100% - var(--ld-sidenav-padding-x)*4 - 0.3125rem);--ld-sidenav-collapse-content-transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) var(--ld-sidenav-transition-delay-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;--ld-sidenav-transition-delay:0s;--ld-sidenav-transition-delay-collapse-expand:0s;--ld-sidenav-transition-duration:0.001s;--ld-sidenav-transition-duration-collapse-expand:0.001s;--ld-sidenav-translate-x-direction:1;--ld-sidenav-stack-to-top-transition:transform var(--ld-sidenav-transition-duration-collapse-expand) var(--ld-sidenav-transition-delay-collapse-expand) ease;--ld-sidenav-bg-color:var(--ld-col-wht);--ld-sidenav-separator-line-bg-col:var(--ld-col-neutral-100);--ld-sidenav-subnav-bg-color:var(--ld-col-wht)}@media (prefers-reduced-motion:no-preference){:host(.ld-sidenav--transitions){--ld-sidenav-transition-duration:0.2s;--ld-sidenav-transition-duration-collapse-expand:0.2s;--ld-sidenav-transition-delay:0.1s;--ld-sidenav-transition-delay-collapse-expand:0.1s}}@media (prefers-reduced-motion:no-preference){:host(.ld-sidenav--toggle-transition-disabled){--ld-sidenav-transition-duration-collapse-expand:0.001s;--ld-sidenav-transition-delay-collapse-expand:0s}}:host{background-color:var(--ld-sidenav-bg-color);bottom:0;box-sizing:border-box;display:flex;flex-direction:column;font:var(--ld-typo-body-m);left:0;overflow:hidden;position:var(--ld-sidenav-position,fixed);text-align:left;top:0;transition:transform var(--ld-sidenav-transition-duration-collapse-expand) ease;width:var(--ld-sidenav-width);z-index:0}:host:before{background-color:var(--ld-sidenav-separator-line-bg-col);bottom:0;content:\"\";position:absolute;right:0;top:0;width:var(--ld-sp-2);z-index:2}:host .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear}:host(.ld-sidenav--closable:not(.ld-sidenav--open)) .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear;visibility:hidden}:host(.ld-sidenav--collapsed:not(.ld-sidenav--closable)){transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*(-100% + var(--ld-sidenav-width-collapsed))))}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible:not(.ld-sidenav--closable)){transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*(-100% + var(--ld-sidenav-width-fully-collapsed))))}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible:not(.ld-sidenav--closable)) .ld-sidenav__content{opacity:0;visibility:hidden}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible.ld-sidenav--transitions:not(.ld-sidenav--closable)) .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear}:host(.ld-sidenav--right){--ld-sidenav-translate-x-direction:-1;--ld-sidenav-translate-x-delta:0;left:unset;right:0}:host(.ld-sidenav--right):before{left:0;right:unset;transform:translateX(-50%) scaleX(1.5)}:host(.ld-sidenav--closable){--ld-sidenav-collapse-content-transition:none;--ld-sidenav-stack-to-top-transition:none;--ld-slider-navitem-move-up-closable:0;--ld-sidenav-translate-x-delta:0;transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*-100%));width:100%}:host(.ld-sidenav--closable.ld-sidenav--open){transform:translateX(0)}:host ::slotted(ld-sidenav-navitem){margin-bottom:var(--ld-sidenav-padding-y)}:host ::slotted(ld-sidenav-navitem[slot=bottom]),:host ::slotted(ld-sidenav-navitem[slot=top]){margin-top:var(--ld-sidenav-padding-y)}:host ::slotted(ld-sidenav-heading){margin:var(--ld-sidenav-padding-y) 0}.ld-sidenav__toggle{-webkit-touch-callout:none;aspect-ratio:1;background-color:var(--ld-col-wht);border:0;border-radius:var(--ld-br-full);box-shadow:var(--ld-shadow-stacked);color:var(--ld-thm-primary);cursor:pointer;display:grid;outline-offset:var(--ld-sp-4);place-content:center;position:absolute;right:0;top:var(--ld-sidenav-toggle-top);touch-action:manipulation;transform:translateX(50%);width:var(--ld-sidenav-toggle-size);will-change:transform;z-index:1}.ld-sidenav__toggle:before{inset:0}.ld-sidenav__toggle:after,.ld-sidenav__toggle:before{border-radius:inherit;content:\"\";display:block;position:absolute}.ld-sidenav__toggle:after{inset:calc(var(--ld-sp-6)*-1)}.ld-sidenav__toggle:focus:focus-visible:not(:active),.ld-sidenav__toggle:hover:not(:active){box-shadow:var(--ld-shadow-sticky)}.ld-sidenav__toggle:where(:focus:focus-visible){color:var(--ld-thm-primary-hover)}.ld-sidenav__toggle:where(:focus:focus-visible):before{background-color:var(--ld-thm-primary-alpha-low)}@media (hover:hover){.ld-sidenav__toggle:where(:hover){color:var(--ld-thm-primary-hover)}}.ld-sidenav__toggle:where(:active),.ld-sidenav__toggle:where(:active:focus-visible){color:var(--ld-thm-primary-active)}:host(.ld-sidenav--right) .ld-sidenav__toggle{left:0;right:unset;transform:translateX(-50%)}.ld-sidenav__toggle-icon{position:relative;transform-origin:center}:host(.ld-sidenav--collapsed) .ld-sidenav__toggle-icon{transform:rotate(180deg)}:host(.ld-sidenav--right) .ld-sidenav__toggle-icon{transform:rotate(180deg)}:host(.ld-sidenav--right.ld-sidenav--collapsed) .ld-sidenav__toggle-icon{transform:none}.ld-sidenav__content{display:flex;flex-direction:column;height:100%;overflow:hidden;will-change:transform}.ld-sidenav__slot-container-default{height:100%;position:relative}.ld-sidenav__slot-container-bottom,.ld-sidenav__slot-container-top{background-color:var(--ld-sidenav-bg-color);position:relative;z-index:1}.ld-sidenav__slot-container-bottom:before,.ld-sidenav__slot-container-default:before,.ld-sidenav__slot-container-top:before{background-color:var(--ld-sidenav-subnav-bg-color);content:\"\";inset:0;opacity:0;position:absolute;transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear;visibility:visible;z-index:0}:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-bottom:before,:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-default:before,:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-top:before{opacity:1}.ld-sidenav__fully-collapsed-click-area{display:none;inset:0;position:absolute;z-index:1}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible:not(.ld-sidenav--closable)) .ld-sidenav__fully-collapsed-click-area{display:block}";

const LdSidenav$1 = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ldSidenavCollapsedChange = createEvent(this, "ldSidenavCollapsedChange", 7);
    this.ldSidenavOpenChange = createEvent(this, "ldSidenavOpenChange", 7);
    this.ldSidenavBreakpointChange = createEvent(this, "ldSidenavBreakpointChange", 7);
    /** Whether the nav should be aligned to the left or the right side of its container. */
    this.align = 'left';
    /**
     * The breakpoint at which the sidenav takes full width and can be
     * opened and closed as opposed to being expanded and collapsed.
     * The prop value is used in a max-width media query.
     */
    this.breakpoint = '23.4375rem';
    /** Indicates that the navigation is collapsed to the side of its container. */
    this.collapsed = false;
    /**
     * Makes the navigation collapse either on
     * - explicit toggle button click,
     * - when the user clicks somewhere outside the element or
     * - when the user moves the cursor / focus outside the element.
     * The modes are inclusive from right to left:
     * - clickoutside applies if the collapse trigger is set to mouseout
     * - toggle applies if the collapse trigger is set to clickoutside
     */
    this.collapseTrigger = 'toggle';
    /**
     * Allows the side navigation to be collapsed to the side of its container.
     */
    this.collapsible = false;
    /**
     * Makes the navigation expand either on
     * - explicit toggle button click,
     * - when the user moves the cursor over the element.
     * The modes are inclusive from right to left:
     * - toggle applies if the expand trigger is set to mouseenter
     */
    this.expandTrigger = 'toggle';
    /** Label to be used for the landmark element (the sidenav itself). */
    this.label = 'Side navigation';
    /**
     * Set to true if you'd like to have a sidenav which partially
     * collapses in way, that slotted ld-navitem components are displayed
     * as icon buttons.
     */
    this.narrow = false;
    /**
     * Indicates that the navigation is visible in a viewport
     * which is smaller than the value of the `breakpoint` prop.
     */
    this.open = false;
    /**
     * Disables transitions on collapsing and expansion of the sidenav.
     * This is especially usefull when the page content gets pushed to
     * the side on sidenav expansion, and you want to prevent too many
     * layout shifts during the transition.
     */
    this.toggleTransitionDisabled = false;
    this.fullyCollapsible = false;
    this.hasActiveSubnav = false;
    this.hasShadowBottom = false;
    this.hasShadowTop = false;
    this.transitions = false;
    this.toFocus = undefined;
    this.focusTimeout = undefined;
    this.updateFocus = () => {
      // HACK: Using recursive call with timeout to account for fast user interactions during transitions.
      clearTimeout(this.focusTimeout);
      if (this.toFocus) {
        if (this.toFocus.tabIndex === -1 ||
          window.getComputedStyle(this.toFocus).visibility === 'hidden') {
          this.focusTimeout = setTimeout(this.updateFocus, 10);
          return;
        }
        this.toFocus.focus();
        this.toFocus = undefined;
      }
    };
    this.toggleCollapsedState = () => {
      this.collapsed = !this.collapsed;
    };
    this.activeSubnavContainsIcons = () => {
      const slider = this.el.querySelector('ld-sidenav-slider');
      const activeSubnav = slider.currentSubnav
        ? this.el.querySelector(`#${slider.currentSubnav}`)
        : slider;
      const navitemsModePrimaryChildren = Array.from(activeSubnav.children).filter((child) => child.tagName === 'LD-SIDENAV-NAVITEM' &&
        !child.mode);
      const navitemsModePrimaryInAccordion = Array.from(activeSubnav.querySelectorAll('ld-sidenav-accordion > ld-sidenav-navitem[slot="toggle"]')).filter((child) => !child.mode);
      const totalNavitemsModePrimary = navitemsModePrimaryChildren.length + navitemsModePrimaryInAccordion.length;
      return !!totalNavitemsModePrimary;
    };
    this.isToggleOutside = (element) => (element === null || element === void 0 ? void 0 : element.tagName) === 'LD-SIDENAV-TOGGLE-OUTSIDE';
    this.onTransitionEnd = (ev) => {
      if (ev.target === this.el) {
        this.transitions = true;
        // If the sidenav was fully collapsed and is being expanded, set the focus
        // on the first focusable element. If it is being collapsed, set the focus
        // on the toggle outside if it is there.
        if (this.fullyCollapsible) {
          if (!this.collapsed) {
            const firstFocusableInSidenav = getFirstFocusable(this.el);
            firstFocusableInSidenav.focus();
          }
          else {
            const previousElementSibling = this.el.previousElementSibling;
            if (this.isToggleOutside(previousElementSibling)) {
              previousElementSibling.focusInner();
            }
          }
        }
      }
    };
    this.onMatchMediaChange = (ev) => {
      this.closable = ev.matches;
      // Remove transitions class on breakpoint change in order to prevent
      // weird looking transitions on screen resize or orientation change events.
      // Add it back on transition end / after style changes have been applied.
      this.transitions = false;
      // When there is less space available than before the breakpoint change,
      // collapse the side nav if it is collapsible.
      if (this.closable && this.collapsible)
        this.collapsed = true;
      this.ldSidenavBreakpointChange.emit(this.closable);
    };
  }
  /**
   * Toggles sidenav.
   */
  async toggle() {
    if (this.closable) {
      this.open = !this.open;
    }
    else {
      this.toggleCollapsedState();
    }
  }
  onCollapsedChange(collapsed) {
    // The ldSidenavCollapsedChange event needs to be emitted even if the
    // sidenav is currently not collapsible (when it is closable), because
    // on breakpoint change its subcomponents need to be rendered according
    // to the new state and thus need to update their state using the event.
    this.ldSidenavCollapsedChange.emit({
      collapsed,
      fully: this.fullyCollapsible,
    });
    if (collapsed) {
      this.open = false;
    }
  }
  onOpenChange(open) {
    this.ldSidenavOpenChange.emit(open);
    if (!open && this.collapsible) {
      this.collapsed = true;
    }
  }
  updateFullyCollapsible() {
    this.fullyCollapsible =
      this.collapsible && (!this.narrow || !this.activeSubnavContainsIcons());
  }
  handleClickOutside(ev) {
    if (['clickoutside', 'mouseout'].includes(this.collapseTrigger) &&
      ev.target.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseOut(ev) {
    if (this.collapseTrigger === 'mouseout' &&
      ev.relatedTarget &&
      ev.relatedTarget.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseIn() {
    if (this.fullyCollapsible || this.expandTrigger === 'mouseenter') {
      this.collapsed = false;
    }
  }
  handleOpen() {
    this.open = true;
  }
  handleClose() {
    clearTimeout(this.focusTimeout);
    this.open = false;
  }
  handleSlideBack() {
    clearTimeout(this.focusTimeout);
    const currentSubnav = Array.from(this.el.querySelectorAll('.ld-sidenav-subnav--active')).pop();
    const currentSubnavId = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.id;
    const parentSubnav = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.parentElement;
    this.el.querySelector('ld-sidenav-slider').navigateBack();
    // Set focus on parent nav-item element as soon as back button looses focus.
    this.toFocus = parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.querySelector(`[to='${currentSubnavId}']`).shadowRoot.querySelector('[part*="focusable"]');
    // Always expand side navigation on back button click.
    this.collapsed = false;
  }
  slideToHandler() {
    var _a;
    clearTimeout(this.focusTimeout);
    // set focus on back button
    const ldSidenavBack = (_a = this.el
      .querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.shadowRoot.querySelector('.ld-sidenav-back');
    this.toFocus = ldSidenavBack;
    this.updateFocus();
  }
  slideChangeHandler(ev) {
    var _a, _b;
    clearTimeout(this.focusTimeout);
    (_a = this.el.querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.updateLabel((_b = ev.detail) === null || _b === void 0 ? void 0 : _b.label);
    this.hasActiveSubnav = !!ev.detail;
    this.updateFullyCollapsible();
    this.updateFocus();
  }
  handleKeyDown(ev) {
    // Ignore events if sidenav has no focus and is not closable.
    const hasSidenavFocus = document.activeElement.closest('ld-sidenav') === this.el;
    if (hasSidenavFocus &&
      ev.key === 'Tab' &&
      !ev.shiftKey &&
      document.activeElement === this.el.querySelector('ld-sidenav-back')) {
      // This block prevents the focus from being set to the wrong element,
      // when a user quickly hits the [Tab] key after triggering the
      // transition to a subnav.
      const { currentSubnav } = this.el.querySelector('ld-sidenav-slider');
      if (currentSubnav) {
        const firstItemOfCurrentSubnav = getFirstFocusable(this.el.querySelector(`#${currentSubnav}`));
        setTimeout(async () => {
          if ('focusInner' in firstItemOfCurrentSubnav) {
            await firstItemOfCurrentSubnav.focusInner();
          }
          else {
            firstItemOfCurrentSubnav.focus();
          }
        });
      }
    }
    if (!hasSidenavFocus && !this.closable) {
      return;
    }
    const slider = this.el.querySelector('ld-sidenav-slider');
    if (ev.key === 'Escape') {
      if (!slider && this.closable) {
        this.open = false;
        return;
      }
      if (this.hasActiveSubnav) {
        this.handleSlideBack();
      }
      else if (this.closable) {
        this.open = false;
      }
    }
  }
  async handleFocusout(ev) {
    const relatedTarget = ev.relatedTarget;
    const isFocusInSidenav = (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest('ld-sidenav')) === this.el;
    // If focus is outside the sidenav and the collapse trigger is set
    // to 'mouseout', collapse the sidenav.
    if (!isFocusInSidenav && relatedTarget !== null) {
      if (this.collapseTrigger === 'mouseout') {
        this.collapsed = this.collapsible;
      }
    }
    // If focus is inside the sidenav expand the sidenav.
    if (this.expandTrigger === 'mouseenter' && isFocusInSidenav) {
      this.collapsed = false;
    }
    // If the sidenav is closable, trap the focus.
    // Do not trap the focus as long as the sidenav is not closable or not open.
    if (!this.closable || !this.open)
      return;
    // Do not trap the focus if the trap focus prop is not set.
    if (this.trapFocus === undefined)
      return;
    // Do not trap the focus as long as the focus remains within the sidenav.
    if (isFocusInSidenav)
      return;
    // Do not trap the focus when it moves to an element which matches
    // the trap focus selector or no element will be focused.
    const isFocusInKeepFocusable = this.trapFocus !== '' &&
      (!relatedTarget || (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.matches(this.trapFocus)));
    if (isFocusInKeepFocusable)
      return;
    // Loop the focus between the ld-sidenav and the elements matching
    // the trap focus selector.
    const target = ev.target;
    const isLeavingSidenav = target.closest('ld-sidenav') === this.el;
    const isLeavingFocusSelectorElement = this.trapFocus !== '' && !!target.closest(this.trapFocus);
    if (!isLeavingSidenav && !isLeavingFocusSelectorElement)
      return;
    const firstFocusableInSidenav = getFirstFocusable(this.el);
    const trapFocusSelectorElements = this.trapFocus === ''
      ? [firstFocusableInSidenav]
      : Array.from(document.querySelectorAll(this.trapFocus));
    const firstFocusableFromSelectorElements = trapFocusSelectorElements.find(getFirstFocusable);
    const isLeavingFirstFocusableInSidenav = firstFocusableInSidenav === target;
    const isLeavingFirstFocusableFromSelectorElements = firstFocusableFromSelectorElements === target;
    const lastFocusableInSidenav = Array.from(this.el.querySelectorAll('*'))
      .reverse()
      .find(getFirstFocusable);
    const lastFocusableFromSelectorElements = trapFocusSelectorElements
      .reverse()
      .find(getFirstFocusable);
    const nextFocused = isLeavingSidenav
      ? isLeavingFirstFocusableInSidenav
        ? lastFocusableFromSelectorElements
        : firstFocusableFromSelectorElements
      : isLeavingFirstFocusableFromSelectorElements
        ? lastFocusableInSidenav
        : firstFocusableInSidenav;
    if (!nextFocused)
      return;
    if ('focusInner' in nextFocused) {
      await nextFocused.focusInner();
    }
    else {
      nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.focus();
    }
  }
  handleHeaderToggleClick() {
    this.toggle();
  }
  componentWillLoad() {
    this.mediaQuery = window.matchMedia(`(max-width: ${this.breakpoint})`);
    this.mediaQuery.addEventListener('change', this.onMatchMediaChange);
    this.closable = this.mediaQuery.matches;
    this.updateFullyCollapsible();
  }
  componentDidLoad() {
    this.ldSidenavCollapsedChange.emit({
      collapsed: this.collapsible && this.collapsed,
      fully: this.fullyCollapsible,
    });
    this.ldSidenavOpenChange.emit(this.open);
    this.ldSidenavBreakpointChange.emit(this.closable);
    setTimeout(() => {
      this.transitions = true;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mediaQuery) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this.onMatchMediaChange);
  }
  render() {
    const cl = [
      'ld-sidenav',
      this.align === 'right' && 'ld-sidenav--right',
      this.transitions && 'ld-sidenav--transitions',
      this.closable && 'ld-sidenav--closable',
      this.collapsible && this.collapsed && 'ld-sidenav--collapsed',
      this.collapsible && 'ld-sidenav--collapsible',
      this.fullyCollapsible && 'ld-sidenav--fully-collapsible',
      this.hasActiveSubnav && 'ld-sidenav--has-active-subnav',
      this.hasShadowTop && 'ld-sidenav--has-shadow-top',
      this.hasShadowBottom && 'ld-sidenav--has-shadow-bottom',
      this.open && 'ld-sidenav--open',
      this.toggleTransitionDisabled && 'ld-sidenav--toggle-transition-disabled',
    ];
    return (h(Host, { onTransitionEnd: this.onTransitionEnd, class: getClassNames(cl), role: "navigation", "aria-label": this.label }, h("slot", { name: "header" }), h("div", { class: "ld-sidenav__content" }, h("div", { class: "ld-sidenav__slot-container-top", part: "slot-container-top" }, h("slot", { name: "top" })), h("ld-sidenav-scroller-internal", { class: "ld-sidenav__scroller", part: "scroll-container" }, h("div", { class: "ld-sidenav__slot-container-default", part: "slot-container" }, h("slot", null))), h("div", { class: "ld-sidenav__slot-container-bottom", part: "slot-container-bottom" }, h("slot", { name: "bottom" }))), h("div", { onClick: this.toggle.bind(this), class: "ld-sidenav__fully-collapsed-click-area" })));
  }
  get el() { return this; }
  static get watchers() { return {
    "collapsed": ["onCollapsedChange"],
    "open": ["onOpenChange"],
    "collapsible": ["updateFullyCollapsible"],
    "narrow": ["updateFullyCollapsible"]
  }; }
  static get style() { return ldSidenavShadowCss; }
}, [1, "ld-sidenav", {
    "align": [1],
    "breakpoint": [1],
    "collapsed": [1028],
    "collapseTrigger": [1, "collapse-trigger"],
    "collapsible": [4],
    "expandTrigger": [1, "expand-trigger"],
    "label": [1],
    "narrow": [4],
    "open": [1028],
    "toggleTransitionDisabled": [4, "toggle-transition-disabled"],
    "trapFocus": [1, "trap-focus"],
    "closable": [32],
    "fullyCollapsible": [32],
    "hasActiveSubnav": [32],
    "hasShadowBottom": [32],
    "hasShadowTop": [32],
    "transitions": [32],
    "toggle": [64]
  }, [[8, "click", "handleClickOutside"], [1, "mouseout", "handleMouseOut"], [1, "mouseenter", "handleMouseIn"], [0, "ldSidenavOpen", "handleOpen"], [0, "ldSidenavClose", "handleClose"], [0, "ldSidenavBack", "handleSlideBack"], [0, "ldSidenavNavitemTo", "slideToHandler"], [0, "ldSidenavSliderChange", "slideChangeHandler"], [9, "keydown", "handleKeyDown"], [9, "focusout", "handleFocusout"], [0, "ldSidenavHeaderToggleClick", "handleHeaderToggleClick"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-sidenav", "ld-sidenav-scroller-internal", "ld-sidenav-separator"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-sidenav":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSidenav$1);
      }
      break;
    case "ld-sidenav-scroller-internal":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "ld-sidenav-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdSidenav = LdSidenav$1;
const defineCustomElement = defineCustomElement$1;

export { LdSidenav, defineCustomElement };
