'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-9117e53d.js');
const getClassNames = require('./getClassNames-dd3906b3.js');
const closest = require('./closest-b87f59c3.js');

const ldSidenavSubnavShadowCss = ":host{--ld-sidenav-accordion-bg-col-hover:var(--ld-col-neutral-100);background:var(\n    --ld-sidenav-bg-color\n  );display:none;height:100%;position:absolute;top:0;transform:translateX(100%);visibility:hidden;width:100%;z-index:1}:host(.ld-sidenav-subnav--active){display:block}:host ::slotted(:where(:not(ld-sidenav-separator):not(ld-sidenav-navitem):not(ld-sidenav-subnav))){margin-bottom:var(--ld-sidenav-padding-y);transition:var(--ld-sidenav-collapse-content-transition);will-change:opacity,transform}:host ::slotted(.ld-sidenav-subnav__hidden){opacity:0;transform:translateX(var(--ld-sidenav-translate-x-delta));transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;visibility:hidden}:host ::slotted(.ld-sidenav-accordion){transform:none}.ld-sidenav-subnav__background{background-color:var(--ld-sidenav-bg-color);inset:0;opacity:0;position:absolute;transition:opacity var(--ld-sidenav-transition-duration) linear}.ld-sidenav-subnav__background:before{background-color:var(--ld-sidenav-subnav-bg-color);content:\"\";inset:0;position:absolute}.ld-sidenav-subnav__background--active{opacity:1}:host(.ld-sidenav-subnav--has-parent-subnav) .ld-sidenav-subnav__background{opacity:1}";

const LdSidenavSubnav = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    /**
     * @internal
     * Internal prop indicating that the subnav is about to become active which
     * may happen before a transition finishes after which it actually becomes active.
     */
    this.activeBeforeTransition = false;
    /**
     * @internal
     * Internal prop indicating that the subnav is either ancestor of the
     * currently visible subnav or the currently visible subnav itself.
     */
    this.active = false;
    /**
     * @internal
     * Internal prop indicating that the subnav is ancestor of the
     * currently visible subnav.
     */
    this.ancestor = false;
    this.toggleVisibilityOnHidableContent = (visible) => {
      Array.from(this.el.children).forEach((el) => {
        // To also hide one of the following elements,
        // it is possible to wrap it in a div with display contents.
        if (![
          'LD-SIDENAV-ACCORDION',
          'LD-SIDENAV-NAVITEM',
          'LD-SIDENAV-SEPARATOR',
          'LD-SIDENAV-SUBNAV',
        ].includes(el.tagName)) {
          el.classList.toggle('ld-sidenav-subnav__hidden', !visible);
        }
      });
    };
  }
  /** Scrolls the subnav scroll container to the top. */
  async scrollToTop(smoothly = false) {
    this.scrollerRef.scrollToTop(smoothly);
  }
  onActiveChange(active) {
    var _a;
    if (active) {
      (_a = this.scrollerRef) === null || _a === void 0 ? void 0 : _a.updateShadows();
    }
  }
  onActiveBeforeTransitionChange(activeBeforeTransition) {
    this.updateBackground(activeBeforeTransition);
  }
  updateBackground(activeBeforeTransition) {
    // HACK: Timeout is required to make the transition work on nav item click
    setTimeout(() => {
      this.bgRef.classList.toggle('ld-sidenav-subnav__background--active', activeBeforeTransition);
    }, 20);
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    if (ev.detail.collapsed) {
      this.scrollToTop(true);
      this.toggleVisibilityOnHidableContent(false);
    }
    else {
      this.toggleVisibilityOnHidableContent(true);
    }
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    const sidenavClosable = ev.detail;
    if (sidenavClosable) {
      this.toggleVisibilityOnHidableContent(true);
    }
    else {
      this.toggleVisibilityOnHidableContent(!this.sidenav.collapsed);
    }
  }
  componentWillLoad() {
    this.sidenav = closest.closest('ld-sidenav', this.el);
    this.hasParentSubnav = this.el.parentElement.tagName === 'LD-SIDENAV-SUBNAV';
  }
  render() {
    const cl = getClassNames.getClassNames([
      'ld-sidenav-subnav',
      this.active && 'ld-sidenav-subnav--active',
      this.hasParentSubnav && 'ld-sidenav-subnav--has-parent-subnav',
    ]);
    return (index.h(index.Host, { class: cl }, index.h("div", { ref: (el) => (this.bgRef = el), class: "ld-sidenav-subnav__background" }), index.h("ld-sidenav-scroller-internal", { style: {
        visibility: !this.active || this.ancestor ? 'hidden' : 'visible',
      }, part: "scroll-container", ref: (el) => (this.scrollerRef = el) }, index.h("slot", null))));
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "active": ["onActiveChange"],
    "activeBeforeTransition": ["onActiveBeforeTransitionChange"]
  }; }
};
LdSidenavSubnav.style = ldSidenavSubnavShadowCss;

exports.ld_sidenav_subnav = LdSidenavSubnav;
