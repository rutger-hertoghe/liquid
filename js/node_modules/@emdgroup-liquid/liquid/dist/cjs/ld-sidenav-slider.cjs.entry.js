'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-9117e53d.js');
const getClassNames = require('./getClassNames-dd3906b3.js');
const closest = require('./closest-b87f59c3.js');

const ldSidenavSliderShadowCss = ":host{display:block;height:100%;position:absolute;transition:transform var(--ld-sidenav-transition-duration) ease;width:100%}:host.ld-sidenav-slider--subnav-active{visibility:hidden}:host ::slotted(:where(:not(ld-sidenav-separator):not(ld-sidenav-navitem):not(ld-sidenav-subnav))){margin-bottom:var(--ld-sidenav-padding-y);transition:var(--ld-sidenav-collapse-content-transition);will-change:opacity,transform}:host ::slotted(.ld-sidenav-slider__hidden){opacity:0;transform:translateX(var(--ld-sidenav-translate-x-delta));transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;visibility:hidden}:host ::slotted(.ld-sidenav-accordion){transform:none}";

const LdSidenavSlider = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.ldSidenavSliderChange = index.createEvent(this, "ldSidenavSliderChange", 7);
    this.activeSubnavs = [];
    this.isFirstLevelHidden = false;
    this.updateActiveBeforeTransition = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.activeBeforeTransition = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.activeBeforeTransition = true;
      });
    };
    this.updateActive = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.active = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.active = true;
      });
    };
    this.updateAncestor = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.ancestor = false;
      });
      // update
      this.activeSubnavs.forEach((subnav, index) => {
        subnav.ancestor = index < this.activeSubnavs.length - 1;
      });
    };
    this.updateFirstLevelHidden = () => {
      this.isFirstLevelHidden = this.currentNavLevel > 0;
    };
    this.scrollInactiveToTop = () => {
      // Scroll all inactive subnav scroll containers to top.
      Array.from(this.el.querySelectorAll('ld-sidenav-subnav')).forEach((subnav) => {
        if (!subnav.active) {
          subnav.scrollToTop();
        }
      });
    };
    this.onTransitionEnd = (ev) => {
      if (ev.target !== this.el)
        return;
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    };
    this.toggleVisibilityOnHidableContent = (visible) => {
      Array.from(this.el.children).forEach((el) => {
        // To also hide one of the following elements,
        // it is possible to wrap it in a div with display contents.
        if (![
          'LD-SIDENAV-ACCORDION',
          'LD-SIDENAV-NAVITEM',
          'LD-SIDENAV-SEPARATOR',
          'LD-SIDENAV-SUBNAV',
        ].includes(el.tagName)) {
          el.classList.toggle('ld-sidenav-slider__hidden', !visible);
        }
      });
    };
  }
  navigateToSubnav() {
    // Make current subnav and all ancestor subnavs active.
    let parentSubnav;
    let subnavId = this.currentSubnav;
    this.activeSubnavs = [];
    while (subnavId) {
      const subnav = document.querySelector(`#${subnavId}`);
      if (subnav) {
        subnav.active = true;
        parentSubnav = subnav.closest(`ld-sidenav-subnav:not(#${subnavId})`);
        this.activeSubnavs.unshift(subnav);
        if (parentSubnav) {
          subnavId = parentSubnav.id;
        }
        else {
          subnavId = undefined;
        }
      }
      else {
        subnavId = undefined;
      }
    }
    if (this.activeSubnavs.length !== this.currentNavLevel) {
      // Condition is true for almost all use cases.
      let needsInertUpdate = false;
      if (this.currentNavLevel === undefined ||
        this.currentNavLevel > this.activeSubnavs.length) {
        needsInertUpdate = true;
        this.updateAncestor();
      }
      this.currentNavLevel = this.activeSubnavs.length;
      if (needsInertUpdate)
        this.updateFirstLevelHidden();
      this.updateActiveBeforeTransition();
    }
    else if (this.activeSubnavs.length > 0) {
      // This condition applies if navigating to a subnav
      // which has the same level as the currently active subnav.
      // This happens on change of the currentSubnav prop from
      // the outside.
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    }
  }
  handleSubnavChange() {
    this.navigateToSubnav();
    this.emitChange();
  }
  slideToHandler(ev) {
    this.currentSubnav = ev.detail.id;
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    if (ev.detail.collapsed) {
      this.scrollerRef.scrollToTop(true);
      this.toggleVisibilityOnHidableContent(false);
    }
    else {
      this.toggleVisibilityOnHidableContent(true);
    }
  }
  handleSidenavBreakpointChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    const sidenavClosable = ev.detail;
    if (sidenavClosable) {
      this.toggleVisibilityOnHidableContent(true);
    }
    else {
      this.toggleVisibilityOnHidableContent(!this.sidenav.collapsed);
    }
  }
  /** Navigates back to the parent nav. */
  async navigateBack() {
    if (this.currentNavLevel > 0) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2];
      this.currentSubnav = (parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.id) || '';
    }
  }
  emitChange() {
    const activeSubnav = this.activeSubnavs[this.activeSubnavs.length - 1];
    if (activeSubnav) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2] || this.el;
      this.ldSidenavSliderChange.emit({
        id: activeSubnav.id,
        label: parentSubnav.label,
      });
    }
    else if (!this.currentSubnav) {
      this.ldSidenavSliderChange.emit();
    }
  }
  componentWillLoad() {
    this.sidenav = closest.closest('ld-sidenav', this.el);
    if (this.currentSubnav) {
      this.handleSubnavChange();
    }
    if (this.currentNavLevel === undefined) {
      this.currentNavLevel = 0;
    }
  }
  render() {
    const cl = getClassNames.getClassNames([
      'ld-sidenav-slider',
      this.currentNavLevel > 0 && 'ld-sidenav-slider--subnav-active',
    ]);
    return (index.h(index.Host, { onTransitionEnd: this.onTransitionEnd, class: cl, style: {
        transform: `translateX(-${this.currentNavLevel}00%)`,
        visibility: this.isFirstLevelHidden ? 'hidden' : 'inherit',
      } }, index.h("ld-sidenav-scroller-internal", { part: "scroll-container", ref: (el) => (this.scrollerRef = el) }, index.h("slot", null))));
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "currentSubnav": ["handleSubnavChange"]
  }; }
};
LdSidenavSlider.style = ldSidenavSliderShadowCss;

exports.ld_sidenav_slider = LdSidenavSlider;
